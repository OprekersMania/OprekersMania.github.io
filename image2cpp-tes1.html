<!--
	"image2cpp"
	Original utility by:
	https://jaspervanloenen.com

	This is the 2nd revision of the modified version by:
	https://wiredolphin.net
	
	This is the 2nd revision of the modified version by:
	https://wiredolphin.net
-->


<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>image2cpp</title>
    <link rel="stylesheet" href="./semantic-ui/semantic.min.css">
    <script src="./semantic-ui/jquery-3.2.1.min.js"></script>
    <script src="./semantic-ui/semantic.min.js"></script>
  
		
	<style>
		html, body {
		  margin: 0 10px;
		  scroll-behavior: smooth;
		}
		.ui.form textarea:not([rows]) {
			font-family: none;
			font-weight: 600;
			font-size: 1em !important;
		}
		
		
		.ui.form .fields {
			border-bottom: 2px solid #000000;
			padding-bottom: 10px;
		}
		
		.ui.form input:not([number]){
			width: 50px;
			padding-top: 1px;
			padding-left: 5px;
			padding-bottom: 1px;
			padding-right: 0px;
			margin-bottom:5px;
		}
		

		.bottom-divider {
			border-bottom: 2px solid #000000;
			padding-bottom: 20px;
		}
		
		.file-input-entry {
			margin-bottom: 10px;
		}
		
		.ui.form select {
			width: 80%;
			}
			
		td {
			vertical-align: top;
			padding-right:50px;
			width:50%;
			}

	
		* {
			margin: 0;
			padding: 0;
		}

		body{
			font-family: arial;
		}

		.section {
			margin: 10px 0;
		}

		.sub-section {
			clear: both;
			margin-bottom: 1px;
		}

		.section,
		.sub-section {
			width: 100%;
		}

		.column {
			float: left;
		}

		.column-center {
			min-width: 160px;
			text-align: center;
		}

		.column-right {
			float: right;
		}

		.sub-section-title {
			margin: 0 0 10px;
		}

		p {
			margin: 20px 0;
		}

		.table {
			display: table;
			margin: 10px 0 0;
			width: 100%;
		}

		
		.table-row {
			display: table-row;
			width: 100%;
		}

		.table-cell {
			display: table-cell;
			padding: 5px 0;
		}

		.table-cell:first-child {
			width: 17%;
		}

		.table-cell:last-child {
			width: 70%;
		}

		.table-cell:first-child label {
			font-weight: bold;
		}

		.table-cell:last-child label {
			margin-right: 10px;
		}

		.nested-table {
			margin: 0;
		}

		.nested-table .table-cell {
			color: #666;
			font-size: .9em;
			width: 200px;
		}

		#format-caption-container div {
			color: #505050;
			display: none;
			font-size: .9em;
			line-height: 1.4em;
			padding: 10px 0 15px;
			width: 100%;
		}

		.byte-input {
			min-height: 160px;
			min-width: 360px;
		}

		.code-output {
			height: 200px;
			width: 100%;
		}

		.note {
			color: #666666;
			font-size: .9em;
			line-height: 1.4em;
			margin: 3px 0;
		}

		input[type="file"] {
			background: #00CB99;
			border-radius: 3px;
			border: none;
			color: #000;
			height: 20px;
			font-size: .9em;
			font-weight: bold;
			padding: 6px 20px;
		}


		.ui.tiny.red.button {
			margin: 0 0 0 10px;
			padding: 4px 6px;
			font-size: unset;
		}

		.file-info {
			max-width: 300px;
			white-space: pre;
		}


		.glyph-input {
			width: 85px;
			margin-left: 10px;
			padding-left: 5px;
		}
		

		#image-size-settings {
			list-style-type: none;
		}

		#image-size-settings li {
			margin: 4px 0;
		}

		#images-canvas-container canvas {
			border: 1px solid red;
			/* margin: 10px 15px; */
		}

		#images-canvas-container {
			align-items: flex-start;
			display: flex;
			flex-wrap: wrap;
		}

		#arduino-identifier,
		#adafruit-gfx-settings,
		#all-same-size {
			display: none;
		}

		.msg {
			font-size: 1.2em;
		}

		.error-msg {
			color: #ff0000;
			display: none;
		}

		h1{
			padding: 10px;
			color: white;
			background-color: #00cb99;
		}
		
		.ui.labeled.input>.label:not(.corner) {
			padding-top: 5px;
			padding-bottom: 5px;
		}
		
.canvasBag {
    margin: 0 10px 10px 0;
    border: 1px solid green;
    padding: 10px;
    background-color: black;
}
		
	</style>
</head>

<body>
	<div style="background-color: #1BFFE3; margin-top: 25px;" class="ui red segment">
			<h2 align="center" style="font-size: 30px;">Image to C++ code generator (2 color only / BW)</h2>
	</div>
	
	<div>
	<p align="center">
			<b>Tata letak dan modifikasi fitur, di desain oleh member facebook,  
				<a href="https://www.facebook.com/profile.php?id=100015443235767" target="_blank">DONY OPREKERS</a>. <br>Sumber original karya <a href="https://github.com/javl" target="_blank">Jasper van Loenen</a> di link asli <a href="http://javl.github.io/image2cpp/" target="_blank">disini.</a>
			</b> <hr>
	</p>
	
	<div class="ui inverted segment">
		<div class="ui form">
		
	<!-------------------------- OPSI 1 ---------------------------->
			<div class="two fields">
					<div class="field" id="file-input-column" style="width:max-content" >
						<h2 class="sub-section-title">1. Select image</h2>
						<input type="file" id="file-input" name="file-input" style="width: max-content;height: 30px; background-color:red; margin: 5px 5px;padding-top: 2px;" multiple="">
					</div>

					<div class="field" id="spacing" style="width:10%;" >
						<h2 class="sub-section-title">or</h2>
					</div>
					
					<div class="field" id="array-input" style="width:-webkit-fill-available; display:block" >
					<div id="array" style="display:block" >
						<h2 class="sub-section-title">1. Paste byte array</h2>
						
						<textarea id="byte-input" class="byte-input"></textarea>
						<div class="text-input-size" style="margin-top: 5px">
							<input class="size-input" type="number" min="0" id="text-input-width" value="40" /> width &emsp;
							<input class="size-input" type="number" min="0" id="text-input-height" value="32" /> height &emsp;
							<button class="ui small inverted violet button" onclick="handleTextInput('horizontal')">Read as horizontal</button>
							<button class="ui small inverted yellow button" onclick="handleTextInput('vertical')">Read as vertical</button>
						</div>
					</div>
					</div>
			</div>
	<!-------------------------- OPSI 2 ---------------------------->

					<div class="field" id="file-input-column">
				<h2>2. Global Image Settings Canvas size(s)</h2>
						<div class="table">

							<div class="table-row">
								<div class="table-cell">
									<ul id="image-size-settings"></ul>
									<div id="only-images-file-error" class="msg error-msg">Only images file type are allowed</div>
									<div id="no-file-selected" class="msg">No files selected</div>
									<button class="ui blue button" id="all-same-size">all same size from first image</button>
								</div>
							</div>

						</div>
					</div>

					
	<!-------------------------- Preview ---------------------------->
		
					<div class="field" id="file-input-column" >
						<h2>3. Preview</h2>
							<div id="images-canvas-container"></div>
					</div>
	<!-------------------------- OPSI 3 ---------------------------->
			<section class="section bottom-divider">
				<h2>3. Image Settings 2</h2>
				<section class="sub-section">
				<table>
				<tbody>
				<tr>
					<td>
						<div class="table-row">
							<div class="table-cell">Background color:</div>
							<div class="table-cell">
								<input id="backgroundColorWhite" type="radio" name="backgroundColor" value="white" checked="checked" onchange="updateRadio('backgroundColor')"/>
								<label for="backgroundColorWhite" class="smallLabel">White</label>
								<input id="backgroundColorBlack" type="radio" name="backgroundColor" value="black" onchange="updateRadio('backgroundColor')"/>
								<label for="backgroundColorBlack" class="smallLabel">Black</label>
								<input id="backgroundColorTransparent" type="radio" name="backgroundColor" value="transparent" onchange="updateRadio('backgroundColor')">
								<label for="backgroundColorTransparent" class="smallLabel">Transparent</label>
							</div>
						</div>

						<div class="table-row">
							<div class="table-cell"><label for="invertColors">Invert image colors</label></div>
							<div class="table-cell">
								<input id="invertColors" type="checkbox" onchange="updateBoolean('invertColors')" />
							</div>
						</div>

						<div class="table-row">
							<div class="table-cell">Brightness / alpha threshold: </div>
							<div class="table-cell">
								<input id="threshold" class="size-input" type="number" min="0" max="255" name="threshold" oninput="updateInteger(&#39;threshold&#39;)" value="128">
								<div class="note">
									<i>0 - 255; if the brightness of a pixel is above the given level the pixel becomes white, otherwise they become black. When using alpha, opaque and transparent are used instead.</i></div>
							</div>
						</div>

						<div class="table-row">
							<div class="table-cell"><label for="scale">Scaling</label></div>
							<div class="table-cell">
								<select id="scale" name="scale" onchange="updateInteger('scale')">
									<option value="1">original size</option>
									<option value="2">scale to fit, keeping proportions</option>
									<option value="3">stretch to fill canvas</option>
									<option value="4">stretch to fill canvas horizontally</option>
									<option value="5">stretch to fill canvas vertically</option>
								</select>
							</div>
						</div>

						<div class="table-row">
							<div class="table-cell">Center:</div>
							<div class="table-cell">
								<input id="centerHorizontally" type="checkbox" onchange="updateBoolean('centerHorizontally')" />
								<label for="centerHorizontally">horizontally</label>
								<input id="centerVertically" type="checkbox" onchange="updateBoolean('centerVertically')" />
								<label for="centerVertically">vertically</label>
							</div>
						</div>

						<div class="table-row">
							<div class="table-cell"><label for="invertColors">Rotate image:</label></div>
							<div class="table-cell">
								<input id="rotate180" type="checkbox" onchange="updateBoolean('rotate180')" />
								<label for="rotate180">rotate 180 degrees</label>
							</div>
						</div>
						<div class="table-row">
							<div class="table-cell">Flip:</div>
							<div class="table-cell">
								<input id="flipHorizontally" type="checkbox" onchange="updateBoolean('flipHorizontally')" />
								<label for="flipHorizontally">horizontally</label>
								<input id="flipVertically" type="checkbox" onchange="updateBoolean('flipVertically')" />
								<label for="flipVertically">vertically</label>
							</div>
						</div>
					</td>
					
					<!---------------------------------------------------------------------------------------------------------->	
					<td>
						<div class="table-row">
							<div class="table-cell"><label for="outputFormat">Code output format</label></div>
							<div class="table-cell">
								<select id="outputFormat" name="outputFormat" onchange="updateOutputFormat(this)">
									<option value="plain">plain bytes</option>
									<option value="arduino">Arduino code</option>
									<option value="arduino_single">Arduino code, single bitmap</option>
									<option value="adafruit_gfx">Adafruit GFXbitmapFont</option>
								</select>
								<div id="format-caption-container">
									<div data-caption="arduino">
										Adds some extra Arduino code around the output for easy copy-paste into
										<a href="https://github.com/javl/image2cpp/blob/master/oled_example/oled_example.ino" target="_blank">this example</a>.
										If multiple images are loaded, generates a byte array for each and appends a counter to the identifier.
									</div>
									<div data-caption="arduino_single">
										Adds some extra Arduino code around the output for easy copy-paste.
										If multiple images are loaded, generates a single byte array.
									</div>
									<div data-caption="adafruit_gfx">
										Creates a <code>GFXbitmapFont</code> formatted ouput. Used by a modified version of the Adafruit GFX library.
										GitHub project and example <a href="https://github.com/wiredolphin/Adafruit-GFX-Library/tree/bitmap-font" target="_blank">here</a>.
										<br />
										<i>First ASCII character</i> value is used only if a glyph identifier of length equal to 1 is not provided for each image. The value itself will be incremented by 1 for each glyph.
									</div>
								</div>
								<div id="extra-settings-container">
									<div id="adafruit-gfx-settings" class="table nested-table">
										<div class="table-row">
											<div class="table-cell">First ASCII character (dec):</div>
											<div class="table-cell">
												<input id="first-ascii-char" class="text-input" type="text" name="first-ascii-char" onchange="" value="48"/>
											</div>
										</div>
										<div class="table-row">
											<div class="table-cell">x advance:</div>
											<div class="table-cell">
												<input id="x-advance" class="text-input" type="text" name="x-advance" onchange="" value="0"/>
											</div>
										</div>
									</div>
									<div id="arduino-identifier" class="table nested-table">
									<br><font style="color:red; font-size:15px">Wajib diisi jika membuat font adafruit</font>
										<div class="table-row">
											<div class="table-cell">Identifier/Prefix:</div>
											<div class="table-cell">
												<input id="identifier" class="text-input" type="text" name="identifier" onchange="" placeholder="New Name" style="width:100px"/>
											</div>
										</div>
									</div>
								</div>
							</div>
						</div>
						
						<div class="table-row">
							<div class="table-cell">Draw mode:</div>
							<div class="table-cell">
								<select id="drawMode" name="drawMode" onchange="updateDrawMode(this)">
									<option value="horizontal1bit">Horizontal - 1 bit per pixel</option>
									<option value="vertical1bit">Vertical - 1 bit per pixel</option>
									<option value="horizontal565">Horizontal - 2 bytes per pixel (565)</option>
									<option value="horizontalAlpha">Horizontal - 1 bit per pixel alpha map</option>
									<option value="horizontal888">Horizontal - 3 bytes per pixel (rgb888)</option>
								</select>
							</div>
						</div>
						
					</td>
				</tr>
				</tbody>
				</table>
					<div class="note">
						<i>Note: centering the image only works when using a canvas larger than the original image.</i><br>
						<i><font style="color:red">If generatif gfx font. image width value must be multiply of 8 </font></i>
					</div>
			</section>
			</section>


	<!-------------------------- OPSI 4 ---------------------------->
			<section class="section">
				<h2>4. Output</h2>
				<section class="sub-section">

					<div id="note1bit">
						<div class="note">
							<i>If your image looks all messed up on your display, like the image below, try using a different mode.</i>
						</div>
						<img class="inlineImg" src=gambar.jpg width="150" height="64" alt="" >
						</img>
					</div>
				</section>
				<section class="sub-section">
					<button type="button" class="ui mini green button" onclick="outputString()">Generate code</button> &emsp;
					<button type="button" class="ui mini blue button" id = "copy-button" onclick="copyOutput()">Copy to Clipboard</button>
					<textarea id="code-output" class="code-output" style="margin-top:10px"></textarea>
				</section>

				
			</section>
			
	</div>
	</div>
	
</body>


<!------------------------------------------------------------------>
<!-------------------------- JAVASCRIPT ---------------------------->
<!------------------------------------------------------------------>

<script type="text/javascript">

// Mengambil semua elemen input dengan class "puter"
        const puterInputs = document.querySelectorAll('.size-input');
		puterInputs.forEach(input => {
			inputPutar(input)
			});
		
		function inputPutar(input){
            input.addEventListener('wheel', function(e) {
                let currentValue = parseFloat(input.value) || 0;
                currentValue += e.deltaY > 0 ? -1 : 1;

                const min = parseFloat(input.min);
                const max = parseFloat(input.max);

                if (!isNaN(min)) currentValue = Math.max(currentValue, min);
                if (!isNaN(max)) currentValue = Math.min(currentValue, max);

                input.value = currentValue;
				e.preventDefault();
            });
        }


		document.getElementById("copy-button").disabled = true;
		var __output;
		var ConversionFunctions = {
			// Output the image as a string for horizontally drawing displays
			horizontal1bit: function (data, canvasWidth, canvasHeight){
				var output_string = "";
				var output_index = 0;

				var byteIndex = 7;
				var number = 0;

				// format is RGBA, so move 4 steps per pixel
				for(var index = 0; index < data.length; index += 4){
					// Get the average of the RGB (we ignore A)
					var avg = (data[index] + data[index + 1] + data[index + 2]) / 3;
					if(avg > settings["threshold"]){
						number += Math.pow(2, byteIndex);
					}
					byteIndex--;

					// if this was the last pixel of a row or the last pixel of the
					// image, fill up the rest of our byte with zeros so it always contains 8 bits
					if ((index != 0 && (((index/4)+1)%(canvasWidth)) == 0 ) || (index == data.length-4)) {
						// for(var i=byteIndex;i>-1;i--){
							// number += Math.pow(2, i);
						// }
						byteIndex = -1;
					}

					// When we have the complete 8 bits, combine them into a hex value
					if(byteIndex < 0){
						var byteSet = number.toString(16);
						if(byteSet.length == 1){ byteSet = "0"+byteSet; }
						var b = "0x"+byteSet;
						output_string += b + ", ";
						output_index++;
						if(output_index >= 16){
							output_string += "\n";
							output_index = 0;
						}
						number = 0;
						byteIndex = 7;
					}
				}
				return output_string;
			},


			// Output the image as a string for vertically drawing displays
			vertical1bit: function (data, canvasWidth, canvasHeight){
				var output_string = "";
				var output_index = 0;

				for(var p=0; p < Math.ceil(settings["screenHeight"] / 8); p++){
					for(var x = 0; x < settings["screenWidth"]; x++){
						var byteIndex = 7;
						var number = 0;

						for (var y = 7; y >= 0; y--){
							var index = ((p*8)+y)*(settings["screenWidth"]*4)+x*4;
							var avg = (data[index] + data[index +1] + data[index +2]) / 3;
							if (avg > settings["threshold"]){
								number += Math.pow(2, byteIndex);
							}
							byteIndex--;
						}
						var byteSet = number.toString(16);
						if (byteSet.length == 1){ byteSet = "0"+byteSet; }
						var b = "0x"+byteSet.toString(16);
						output_string += b + ", ";
						output_index++;
						if(output_index >= 16){
							output_string += "\n";
							output_index = 0;
						}
					}
				}
				return output_string;
			},

			// Output the image as a string for 565 displays (horizontally)
			horizontal565: function (data, canvasWidth, canvasHeight){
				var output_string = "";
				var output_index = 0;

				// format is RGBA, so move 4 steps per pixel
				for(var index = 0; index < data.length; index += 4){
					// Get the RGB values
					var r = data[index];
					var g = data[index + 1];
					var b = data[index + 2];
					// calculate the 565 color value
					var rgb = ((r & 0b11111000) << 8) | ((g & 0b11111100) << 3) | ((b & 0b11111000) >> 3);
					// Split up the color value in two bytes
					var firstByte = (rgb >> 8) & 0xff;
					var secondByte = rgb & 0xff;

					var byteSet = rgb.toString(16);
					while(byteSet.length < 4){ byteSet = "0" + byteSet; }
					output_string += "0x" + byteSet + ", ";

					// add newlines every 16 bytes
					output_index++;
					if(output_index >= 16){
						output_string += "\n";
						output_index = 0;
					}
				}
				return output_string;
			},
			// Output the image as a string for rgb888 displays (horizontally)
			horizontal888: function (data, canvasWidth, canvasHeight){
				var output_string = "";
				var output_index = 0;

				// format is RGBA, so move 4 steps per pixel
				for(var index = 0; index < data.length; index += 4){
					// Get the RGB values
					var r = data[index];
					var g = data[index + 1];
					var b = data[index + 2];
					// calculate the 565 color value
					var rgb = (r << 16) | (g << 8) | (b);
					// Split up the color value in two bytes
					var firstByte = (rgb >> 8) & 0xff;
					var secondByte = rgb & 0xff;

					var byteSet = rgb.toString(16);
					while(byteSet.length < 8){ byteSet = "0" + byteSet; }
					output_string += "0x" + byteSet + ", ";

					// add newlines every 16 bytes
					output_index++;
					if(output_index >= canvasWidth){
						output_string += "\n";
						output_index = 0;
					}
				}
				return output_string;
			},
			// Output the alpha mask as a string for horizontally drawing displays
			horizontalAlpha: function (data, canvasWidth, canvasHeight){
				var output_string = "";
				var output_index = 0;

				var byteIndex = 7;
				var number = 0;

				// format is RGBA, so move 4 steps per pixel
				for(var index = 0; index < data.length; index += 4){
					// Get alpha part of the image data
					var alpha = data[index + 3];
					if(alpha > settings["threshold"]){
						number += Math.pow(2, byteIndex);
					}
					byteIndex--;

					// if this was the last pixel of a row or the last pixel of the
					// image, fill up the rest of our byte with zeros so it always contains 8 bits
					if ((index != 0 && (((index/4)+1)%(canvasWidth)) == 0 ) || (index == data.length-4)) {
						byteIndex = -1;
					}

					// When we have the complete 8 bits, combine them into a hex value
					if(byteIndex < 0){
						var byteSet = number.toString(16);
						if(byteSet.length == 1){ byteSet = "0"+byteSet; }
						var b = "0x"+byteSet;
						output_string += b + ", ";
						output_index++;
						if(output_index >= 16){
							output_string += "\n";
							output_index = 0;
						}
						number = 0;
						byteIndex = 7;
					}
				}
				return output_string;
			}
		};

		// An images collection with helper methods
		function Images() {
			var collection = [];
			this.push = function(img, canvas, glyph) {
				collection.push({ "img" : img, "canvas" : canvas, "glyph" : glyph });
			};
			this.remove = function(image) {
				var i = collection.indexOf(image);
				if(i != -1) collection.splice(i, 1);
			};
			this.each = function(f) { collection.forEach(f); };
			this.length = function() { return collection.length; };
			this.first = function() { return collection[0]; };
			this.last = function() { return collection[collection.length - 1]; };
			this.getByIndex = function(index) { return collection[index]; };
			this.setByIndex = function(index, img) { collection[index] = img; };
			this.get = function(img) {
				if(img) {
					for(var i = 0; i < collection.length; i++) {
						if(collection[i].img == img) {
							return collection[i];
						}
					}
				}
				return collection;
			};
			return this;
		}

		// Add events to the file input button
		var fileInput = document.getElementById("file-input");
		fileInput.addEventListener("click", function(){this.value = null;}, false);
		fileInput.addEventListener("change", handleImageSelection, false);

		var fileInputColumn = document.getElementById("file-input-column");

		// Filetypes accepted by the file picker
		var fileTypes = ["jpg", "jpeg", "png", "bmp", "gif", "svg"];

		// The canvas we will draw on
		var canvasContainer = document.getElementById("images-canvas-container");
		// multiple images settings container
		var imageSizeSettings = document.getElementById("image-size-settings");
		// all images same size button
		var allSameSizeButton = document.getElementById("all-same-size");
		// error message
		var onlyImagesFileError = document.getElementById("only-images-file-error");
		// initial message
		var noFileSelected = document.getElementById("no-file-selected");
		var showArray = document.getElementById("array-input");
		var showspacing = document.getElementById("spacing");

		// The variable to hold our images. Global so we can easily reuse it when the
		// user updates the settings (change canvas size, scale, invert, etc)
		var images = new Images();

		// A bunch of settings used when converting
		var settings = {
			W_offset: 0,
			H_offset: 0,
			X_offset: 0,
			Y_offset: 0,
			screenWidth: 0,
			screenHeight: 0,
			scaleToFit: true,
			preserveRatio: true,
			centerHorizontally: false,
			centerVertically: false,
			flipHorizontally: false,
			flipVertically: false,
			backgroundColor: "white",
			scale: "1",
			drawMode: "horizontal",
			threshold: 128,
			outputFormat: "plain",
			invertColors: false,
			rotate180: false,
			conversionFunction: ConversionFunctions.horizontal1bit
		};

		// Variable name, when "arduino code" is required
		var identifier = "newFont";

		function update() {
			images.each(function(image) { place_image(image); });
		}

		// Easy way to update settings controlled by a textfield
		function updateInteger(fieldName){
			settings[fieldName] = document.getElementById(fieldName).value;
			update();
		}

		// Easy way to update settings controlled by a checkbox
		function updateBoolean(fieldName){
			settings[fieldName] = document.getElementById(fieldName).checked;
			update();
		}

		// Easy way to update settings controlled by a radiobutton
		function updateRadio(fieldName){
			var radioGroup = document.getElementsByName(fieldName);
			for (var i = 0; i < radioGroup.length; i++) {
				if (radioGroup[i].checked) {
					settings[fieldName] = radioGroup[i].value;
				}
			}
			update();
		}

		// Updates Arduino code check-box
		function updateOutputFormat(elm) {
			var caption = document.getElementById("format-caption-container");
			var adafruitGfx = document.getElementById("adafruit-gfx-settings");
			var arduino = document.getElementById("arduino-identifier");

			for(var i = 0; i < caption.children.length; i++) {
				caption.children[i].style.display = "none";
			}
			caption = document.querySelector("div[data-caption='" + elm.value + "']");
			if(caption) caption.style.display = "block";

			elm.value != "plain" ? arduino.style.display = "block" : arduino.style.display = "none";
			elm.value == "adafruit_gfx" ? adafruitGfx.style.display = "block" : adafruitGfx.style.display = "none";

			settings["outputFormat"] = elm.value;
		}

		function updateDrawMode(elm) {
			var note = document.getElementById("note1bit");
			if(elm.value == "horizontal1bit" || elm.value == "vertical1bit") {
				note.style.display = "block";
			} else {
				note.style.display = "none";
			}

			var conversionFunction = ConversionFunctions[elm.value];
			if(conversionFunction) {
				settings.conversionFunction = conversionFunction;
			}
		}

		// Make the canvas black and white
		function blackAndWhite(canvas, ctx){
			var imageData = ctx.getImageData(0,0,canvas.width, canvas.height);
			var data = imageData.data;
			for (var i = 0; i < data.length; i += 4) {
				var avg = (data[i] + data[i +1] + data[i +2]) / 3;
				avg > settings["threshold"] ? avg = 255 : avg = 0;
				data[i]     = avg; // red
				data[i + 1] = avg; // green
				data[i + 2] = avg; // blue
			}
			ctx.putImageData(imageData, 0, 0);
		}

		// Invert the colors of the canvas
		function invert(canvas, ctx) {
			var imageData = ctx.getImageData(0,0,canvas.width, canvas.height);
			var data = imageData.data;
			for (var i = 0; i < data.length; i += 4) {
				data[i]     = 255 - data[i];     // red
				data[i + 1] = 255 - data[i + 1]; // green
				data[i + 2] = 255 - data[i + 2]; // blue
			}
			ctx.putImageData(imageData, 0, 0);
		}

		// Handle inserting an image by pasting code
		function handleTextInput(drawMode){

			var canvas = document.createElement("canvas");
			canvas.width = parseInt(document.getElementById("text-input-width").value);
			canvas.height = parseInt(document.getElementById("text-input-height").value);
			settings["screenWidth"] = canvas.width;
			settings["screenHeight"] = canvas.height;

			if(canvasContainer.children.length) {
				canvasContainer.removeChild(canvasContainer.firstChild);
			}
			canvasContainer.appendChild(canvas);

			var image = new Image();
			images.setByIndex(0, {"img": image, "canvas" : canvas});

			let input = document.getElementById("byte-input").value;

			let re = /{([\s\S]*?)}/;
			let last_match = input.match(re);
			input = last_match ? last_match[0] : "";
			
			input = input.replace(/\}|\{/g, "");

			// Convert newlines to comma (helps to remove comments later)
			input = input.replace(/\r\n|\r|\n/g, ",");
			// Convert multiple commas in a row into a single one
			input = input.replace(/,{2,}/g, ",");
			// Remove whitespace
			input = input.replace(/\s/g, "");
			//Remove comments
			input = input.replace(/\/\/(.+?),/g, "");
			// Remove "0x"
			input = input.replace(/0[xX]/g, "");
			// Split into list
			var list = input.split(",");
			console.log(list);

			if(drawMode == "horizontal"){
				listToImageHorizontal(list, canvas);
			}else{
				listToImageVertical(list, canvas);
			}
		}




		function allSameSize(images, files) {
			if(images.length() > 1 && images.length() == files.length) {
				var inputs = canvasContainer.querySelectorAll("input");
				allSameSizeButton.onclick = function() {
					for(var i = 2; i < inputs.length; i++) {
						if(inputs[i].name == "width") {
							inputs[i].value = inputs[0].value;
							inputs[i].oninput();
						}
						if(inputs[i].name == "height") {
							inputs[i].value = inputs[1].value;
							inputs[i].oninput();
						}

					}
				};
				allSameSizeButton.style.display = "block";
			}
		}

		// Handle selecting an image with the file picker
		function handleImageSelection(evt){
			
			var files = evt.target.files;
			showArray.style.display = "none";
			showspacing.style.display = "none";
			onlyImagesFileError.style.display = "none";

			files.length > 0 ? noFileSelected.style.display = "none" : noFileSelected.style.display = "block";

			for (var i = 0, f; f = files[i]; i++) {

				// Only process image files.
				if(!f.type.match("image.*")) {
				onlyImagesFileError.style.display = "block";
					continue;
				}

				var reader = new FileReader();

				reader.onload = (function(file) {
					return function(e) {
						// Render thumbnail.
						var img = new Image();
				img.offsetX = 0;
				img.offsetY = 0;

						img.onload = function(){
							var fileInputColumnEntry = document.createElement("div");
							fileInputColumnEntry.className = "file-input-entry";

							var fileInputColumnEntryLabel = document.createElement("span");
							fileInputColumnEntryLabel.textContent = file.name;

							var fileInputColumnEntryRemoveButton = document.createElement("button");
							fileInputColumnEntryRemoveButton.className = "ui mini inverted red button right floated";
							fileInputColumnEntryRemoveButton.innerHTML = "Remove";

							var fileInputColumnEntrySaveButton = document.createElement("button");
							fileInputColumnEntrySaveButton.className = "ui mini inverted blue button right floated";
							fileInputColumnEntrySaveButton.innerHTML = "save img";

							var canvas = document.createElement("canvas");

							var imageEntry = document.createElement("div");
							imageEntry.setAttribute("data-img", file.name);
							// imageEntry.setAttribute("style", "margin-bottom: 10px; padding-left: 15px;");

							var w = document.createElement("input");
							w.type = "number";
							w.name = "width";
							w.id = "screenWidth";
							w.min = 0;
							w.className = "size-input";
							w.value = img.width;
							settings["screenWidth"] = img.width;
							w.oninput = function() {
								canvas.width = this.value;
								update();
								updateInteger('screenWidth');
							};

							var h = document.createElement("input");
							h.type = "number";
							h.name = "height";
							h.id = "screenHeight";
							h.min = 0;
							h.className = "size-input";
							h.value = img.height;
							settings["screenHeight"] = img.height;
							h.oninput = function() {
								canvas.height = this.value;
								update();
								updateInteger('screenHeight');
							};

							var gi = document.createElement("input");
							gi.type = "text";
							gi.name = "glyph";
							gi.className = "glyph-input";
							gi.onchange = function() {
								var image = images.get(img);
								image.glyph = gi.value;
							};
					
							var Xo = document.createElement("input");
							Xo.type = "number";
							Xo.name = "Xoffset";
							Xo.id = "X_offset";
							Xo.min = -160;
							Xo.className = "size-input";
							Xo.value = img.offsetX;
							Xo.oninput = function() {
								img.offsetX = this.value;
								update();
								updateInteger('X_offset');
							};

							var Yo = document.createElement("input");
							Yo.type = "number";
							Yo.name = "Yoffset";
							Yo.id = "Y_offset";
							Yo.min = -160;
							Yo.className = "size-input";
							Yo.value = img.offsetY;
							Yo.oninput = function() {
								img.offsetY = this.value;
								update();
								updateInteger('Y_offset');
							};
			
								var Wo = document.createElement("input");
								Wo.type = "number";
								Wo.name = "Woffset";
								Wo.id = "W_offset";
								Wo.min = 0;
								Wo.className = "size-input";
								Wo.value = img.width;
								settings["W_offset"] = Wo.value;
								Wo.oninput = function() {
									img.width = this.value;
									update();
									updateInteger('W_offset');
								};

								var Ho = document.createElement("input");
								Ho.type = "number";
								Ho.name = "Hoffset";
								Ho.id = "H_offset";
								Ho.min = 0;
								Ho.className = "size-input";
								Ho.value = img.height;
								settings["H_offset"] = Ho.value;
								Ho.oninput = function() {
									img.height = this.value;
									update();
									updateInteger('H_offset');
								};

							var fn = document.createElement("span");
							fn.className = "file-info";
							fn.innerHTML = file.name + "<br>(File resolution: " + img.width + " x " + img.height + ")<br>";

							var gil = document.createElement("span");
							gil.innerHTML = " New Name    ";
							gil.className = "file-info";

							var rb = document.createElement("button");
							rb.className = "ui tiny red button";
							rb.innerHTML = "Remove";

							var Wd = document.createElement("span");
							Wd.innerHTML = " Width    ";
							Wd.className = "file-info";
							
							var Hg = document.createElement("span");
							Hg.innerHTML = " Height    ";
							Hg.className = "file-info";
							
							var Hs = document.createElement("span");
							Hs.innerHTML = " H-shift    ";
							Hs.className = "file-info";
							
							var Vs = document.createElement("span");
							Vs.innerHTML = " V-shift    ";
							Vs.className = "file-info";
							
							var Ht = document.createElement("span");
							Ht.innerHTML = " H-trim    ";
							Ht.className = "file-info";
							
							var Vt = document.createElement("span");
							Vt.innerHTML = " V-trim    ";
							Vt.className = "file-info";
							
							
							var buttonList = document.createElement("div");
							buttonList.className = "ui mini right labeled input";
							buttonList.setAttribute("style", "font-size:1em; width: 55px;");
							
							var buttonLabel = document.createElement("div");
							buttonLabel.className = "ui mini green label";
							
							const removeButtonOnClick = function() {
								var image = images.get(img);
								canvasContainer.removeChild(bag);
								bag.removeChild(image.canvas);
								images.remove(image);
								fileInputColumn.removeChild(fileInputColumnEntry);
								if(canvasContainer.children.length == 1) {
									allSameSizeButton.style.display = "none";
								}
								if(images.length() == 0) {
									noFileSelected.style.display = "block";
									showArray.style.display = "block";
									showspacing.style.display = "block";
									}
								update();
							};

							var BR = document.createElement("br");
							
							var sb = document.createElement("button");
							sb.className = "ui tiny red button";
							sb.innerHTML = "save img";
							const saveButtonOnClick = function() {
							  const image = canvas.toDataURL('image/jpeg'); // Use 'image/jpeg' MIME type
							  const link = document.createElement('a');
							  link.href = image;
							  link.download = 'image.jpg'; // Use '.jpg' extension
							  link.click();
							};
							sb.onclick = saveButtonOnClick;
							fileInputColumnEntrySaveButton.onclick = saveButtonOnClick;
							rb.onclick = removeButtonOnClick;
							fileInputColumnEntryRemoveButton.onclick = removeButtonOnClick;

							fileInputColumnEntry.appendChild(fileInputColumnEntryLabel);
							fileInputColumnEntry.appendChild(fileInputColumnEntryRemoveButton);
							fileInputColumnEntry.appendChild(fileInputColumnEntrySaveButton);
							fileInputColumn.appendChild(fileInputColumnEntry);
							
							var bag = document.createElement("div");
								bag.className = "canvasBag";
								// bag.style ="margin:10px;border:solid 1px green; padding:10px";
							imageEntry.appendChild(fn);
							imageEntry.appendChild(w);
							imageEntry.appendChild(Wd);
							imageEntry.appendChild(h);
							imageEntry.appendChild(Hg);
							imageEntry.appendChild(document.createElement("br"));
							imageEntry.appendChild(Xo);
							imageEntry.appendChild(Hs);
							imageEntry.appendChild(Yo);
							imageEntry.appendChild(Vs);
							imageEntry.appendChild(document.createElement("br"));
							imageEntry.appendChild(Wo);
							imageEntry.appendChild(Ht);
							imageEntry.appendChild(Ho); 
							imageEntry.appendChild(Vt);
							imageEntry.appendChild(document.createElement("br"));
							imageEntry.appendChild(gi);
							imageEntry.appendChild(gil);
							imageEntry.appendChild(document.createElement("br"));
							imageEntry.appendChild(rb);
							imageEntry.appendChild(sb);

							// imageSizeSettings.appendChild(imageEntry)
							
							// inputPutar(w); -->
							// inputPutar(h); -->
							// inputPutar(Xo); -->
							// inputPutar(Yo); -->
							// inputPutar(Wo); -->
							// inputPutar(Ho); -->
							
								canvas.width = img.width;
								canvas.height = img.height;
							bag.appendChild(canvas);
							bag.appendChild(imageEntry);
							canvasContainer.appendChild(bag);
							images.push(img, canvas, file.name.split(".")[0]);
							place_image(images.last());
							allSameSize(images, files);
						};
						img.src = e.target.result;
					};
				})(f);
				reader.readAsDataURL(f);
			}
		}

		// Draw the image onto the canvas, taking into account color and scaling
		function place_image(image){

			var img = image.img;
			var canvas = image.canvas;
			var ctx = canvas.getContext("2d");
			image.ctx = ctx;

			// Invert background if needed
			if (settings["backgroundColor"] == "transparent") {
				ctx.fillStyle = "rgba(0,0,0,0.0)";
				ctx.globalCompositeOperation = 'copy';
			} else {
				if (settings["invertColors"]){
					settings["backgroundColor"] == "white" ? ctx.fillStyle = "black" : ctx.fillStyle = "white";
				} else {
					ctx.fillStyle = settings["backgroundColor"];
				}
				ctx.globalCompositeOperation = 'source-over';
			}
			ctx.fillRect(0, 0, canvas.width, canvas.height);

			ctx.setTransform(1, 0, 0, 1, 0, 0); // start with identity matrix transform (no rotation).
			if(settings["rotate180"]){
				// Matrix transformation
				ctx.translate(canvas.width/2.0, canvas.height/2.0);
				ctx.rotate(Math.PI);
				ctx.translate(-canvas.width/2.0, -canvas.height/2.0);
			}


			// Offset used for centering the image when requested
			var offset_x = 0;
			var offset_y = 0;
			
			switch(settings["scale"]){
				case "1": // Original
					if(settings["centerHorizontally"]){ offset_x = Math.round((canvas.width - img.width) / 2); }
					if(settings["centerVertically"]){ offset_y = Math.round((canvas.height - img.height) / 2); }
					ctx.drawImage(img, img.offsetX, img.offsetY, img.width, img.height,
						offset_x , offset_y , img.width, img.height);
				break;
				case "2": // Fit (make as large as possible without changing ratio)
					var horRatio = canvas.width / img.width;
					var verRatio =  canvas.height / img.height;
					var useRatio  = Math.min(horRatio, verRatio);

					if(settings["centerHorizontally"]){ offset_x = Math.round((canvas.width - img.width*useRatio) / 2); }
					if(settings["centerVertically"]){ offset_y = Math.round((canvas.height - img.height*useRatio) / 2); }
					ctx.drawImage(img, img.offsetX, img.offsetY, img.width, img.height,
						offset_x, offset_y, img.width * useRatio, img.height * useRatio);
				break;
				case "3": // Stretch x+y (make as large as possible without keeping ratio)
					ctx.drawImage(img, img.offsetX, img.offsetY, img.width, img.height,
						offset_x, offset_y, canvas.width, canvas.height);
				break;
				case "4": // Stretch x (make as wide as possible)
					offset_x = 0;
					if(settings["centerVertically"]){ Math.round(offset_y = (canvas.height - img.height) / 2); }
					ctx.drawImage(img, img.offsetX, img.offsetY, img.width, img.height,
						offset_x, offset_y, canvas.width, img.height);
				break;
				case "5": // Stretch y (make as tall as possible)
					if(settings["centerHorizontally"]){ offset_x = Math.round((canvas.width - img.width) / 2); }
					offset_y = 0;
					ctx.drawImage(img, img.offsetX, img.offsetY, img.width, img.height,
						offset_x, offset_y, img.width, canvas.height);
				break;
			}
			// Make sure the image is black and white
			if(settings.conversionFunction == ConversionFunctions.horizontal1bit
				|| settings.conversionFunction == ConversionFunctions.vertical1bit) {
				blackAndWhite(canvas, ctx);
				if(settings["invertColors"]){
					invert(canvas, ctx);
				}
			}

			// Flip image if needed
			if (settings["flipHorizontally"]) {
				ctx.save();
				ctx.scale(-1, 1);
				ctx.drawImage(canvas, -canvas.width, 0);
				ctx.restore();
			}
			if (settings["flipVertically"]) {
				ctx.save();
				ctx.scale(1, -1);
				ctx.drawImage(canvas, 0, -canvas.height);
				ctx.restore();
			}
		}


		function imageToString(image){
			// extract raw image data
			var ctx = image.ctx;
			var canvas = image.canvas;

			var imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
			var data = imageData.data;
			return settings.conversionFunction(data, canvas.width, canvas.height);
		}

		// Get the custom arduino output variable name, if any
		function getIdentifier() {
			var vn = document.getElementById("identifier");
			return vn && vn.value.length ? vn.value : identifier;
		}

		// Output the image string to the textfield
		function outputString(){

			var output_string = "", count = 1;
			var code = "";
			var bmp_P= document.getElementById("screenWidth").value;
			bmp_P = (Math.round(bmp_P / 8)*5);

			
			switch(settings["outputFormat"]) {

				case "arduino": {
					let varQuickArray = [];
					let bytesUsed     = 0;
					// --
					images.each(function(image) {
						code = imageToString(image);

						code = code.replace(/\s|\n/g,"");
						
						
						let regex = new RegExp('(.{'+bmp_P+'})', "g");
						code = code.replace(regex,"$1\n");
						// Trim whitespace from end and remove trailing comma
						code = code.replace(/,\s*$/," ");

						//code = code.match(/.{1,16}/gm).join("\n");
						code = "\t" + code.split("\n").join("\n\t") + "\n";
						//document.getElementById("ngetes3").value = code;

						
						var variableCount = images.length() > 1 ? count++ : "";
						var comment = "// " + image.glyph + ", " + image.canvas.width + " , " + image.canvas.height + " px\n";
						bytesUsed += code.split("\n").length * 16; // 16 bytes per line.
						console.log(image);

						let varname = getIdentifier() + image.glyph.replace(/[^a-zA-Z0-9]/g,"_");
						varQuickArray.push(varname);
						code = comment + "const " + getType() + " " + varname + " [] PROGMEM = {\n" + code + "};\n";
						output_string += code;
					});
					// --
					varQuickArray.sort();
					// --
					output_string = "\n// Array of all bitmaps for convenience. (Total bytes used to store images in PROGMEM = "+bytesUsed+")\n" + output_string;
					// --
					break;
				}

				case "arduino_single": {
					var comment = "";
					images.each(function(image) {
						code = imageToString(image);
						code = "\t" + code.split("\n").join("\n\t") + "\n";
						comment = "\t// '" + image.glyph + ", " + image.canvas.width+"x"+image.canvas.height+"px\n";
						output_string += comment + code;
					});

					output_string = output_string.replace(/,\s*$/,"");

					output_string = "const " + getType() + " " +
						+ getIdentifier()
						+ " [] PROGMEM = {"
						+ "\n" + output_string + "\n};";
					break;
				}

				case "adafruit_gfx": { // bitmap
					var comment = "";
					var useGlyphs = 0;
					images.each(function(image) {
						code = imageToString(image);
						count = code.split(",").length;
						code = "\t" + code.split("\n").join("\n\t") + "\n";
						//comment = "\t// '" + image.glyph + ", " + image.canvas.width+"x"+image.canvas.height+"px\n";
						output_string += code;
						if(image.glyph.length == 1) {
							useGlyphs++;
						}
					});
					

					output_string = output_string.replace(/,\s*$/,"");
					output_string = "const uint8_t "
						+ getIdentifier()
						+ "Bitmaps"
						+ "[] PROGMEM = {"
						+ "\n" + output_string + "\n};\n\n"
						+ "const GFXglyph "
						+ getIdentifier()
						+ "Glyphs[] PROGMEM = {\n";

					var firstAschiiChar = document.getElementById("first-ascii-char").value;
					var xAdvance = parseInt(document.getElementById("x-advance").value);
					var offset = 0;
					var fontheight = 0;
					var firstchar = toHex(parseInt(firstAschiiChar));
					var lastchar = parseInt(firstAschiiChar)+parseInt((images.length()-1));
					if(lastchar == 1) lastchar = toHex(firstAschiiChar);
					code = "";

					// GFXbitmapGlyph
					images.each(function(image) {
						if (fontheight == 0) fontheight = image.canvas.height;
						var base = (image.canvas.height - (image.canvas.height*2))+1;
						code += "\t{ "
							+ offset + ", "
							+ image.canvas.width + ", "
							+ image.canvas.height + ", "
							+ (image.canvas.width + xAdvance) + ", 0, " + base + " },"
							+ "\t// '" + (images.length() == useGlyphs ?
								image.glyph :
									String.fromCharCode(firstAschiiChar++)) + "'";
							
						if(image != images.last()){ code += ","; }
						code += "  --  '" + image.glyph + "'\n";
						offset += (count-1);
					});
					code += "};\n";
					output_string += code;
					var lastchar = toHex(lastchar);

					// GFXbitmapFont
					output_string += "\nconst GFXfont "
						+ getIdentifier()
						+ " PROGMEM = {\n"
						+ "\t(uint8_t *)"
						+ getIdentifier() + "Bitmaps,\n"
						+ "\t(GFXglyph *)"
						+ getIdentifier()
						+ "Glyphs,\n"
						+ "\t0x" + firstchar + ", 0x" + lastchar
						+  ", " + fontheight + "\n};\n";
					break;
				}
				default: { // plain
					images.each(function(image) {
						code = imageToString(image);
						var comment = image.glyph ? ("// '" + image.glyph + "', " + image.canvas.width+"x"+image.canvas.height+"px\n") : "";
						if(image.img != images.first().img) comment = "\n" + comment;
						code = comment + code;
						output_string += code;
					});
					// Trim whitespace from end and remove trailing comma
					output_string = output_string.replace(/,\s*$/g,"");
				}
			}

			document.getElementById("code-output").value = output_string;
			__output = output_string;
			document.getElementById("copy-button").disabled = false;
		}

		function copyOutput() {
			  var copyText = document.getElementById("code-output");
			  copyText.select();
			  copyText.setSelectionRange(0, 9999999); /*Change higher if all content not copied*/
			  document.execCommand("copy");
		}

		// Use the horizontally oriented list to draw the image
		function listToImageHorizontal(list, canvas){

			var ctx = canvas.getContext("2d");
			ctx.clearRect(0, 0, canvas.width, canvas.height);

			var imgData = ctx.createImageData(canvas.width, canvas.height);

			var index = 0;

			var page = 0;
			var x = 0;
			var y = 7;
			// round the width up to the next byte
			var widthRoundedUp = Math.floor(canvas.width / 8 + (canvas.width % 8 ? 1 : 0)) * 8;
			var widthCounter = 0;

			// Move the list into the imageData object
			for (var i=0;i<list.length;i++){

				var binString = hexToBinary(list[i]);
				if(!binString.valid){
					alert("Something went wrong converting the string. Did you forget to remove any comments from the input?");
					console.log("invalid hexToBinary: ", binString.s);
					return;
				}
				binString = binString.result;
				if (binString.length == 4){
					binString = binString + "0000";
				}

				// Check if pixel is white or black
				for(var k=0; k<binString.length; k++, widthCounter++){
					// if we've counted enough bits, reset counter for next line
					if(widthCounter >= widthRoundedUp) {
						widthCounter = 0;
					}
					// skip 'artifact' pixels due to rounding up to a byte
					if(widthCounter >= canvas.width) {
						continue;
					}
					var color = 0;
					if(binString.charAt(k) == "1"){
						color = 255;
					}
					imgData.data[index] = color;
					imgData.data[index+1] = color;
					imgData.data[index+2] = color;
					imgData.data[index+3] = 255;

					index += 4;
				}
			}

			// Draw the image onto the canvas, then save the canvas contents
			// inside the img object. This way we can reuse the img object when
			// we want to scale / invert, etc.
			ctx.putImageData(imgData, 0, 0);
			var img = new Image();
			img.src = canvas.toDataURL("image/png");
			images.first().img = img;
		}

		// Use the vertically oriented list to draw the image
		function listToImageVertical(list, canvas){

			var ctx = canvas.getContext("2d");
			ctx.clearRect(0, 0, canvas.width, canvas.height);

			var index = 0;

			var page = 0;
			var x = 0;
			var y = 7;

			// Move the list into the imageData object
			for (var i=0;i<list.length;i++){

				var binString = hexToBinary(list[i]);
				if(!binString.valid){
					alert("Something went wrong converting the string. Did you forget to remove any comments from the input?");
					console.log("invalid hexToBinary: ", binString.s);
					return;
				}
				binString = binString.result;
				if (binString.length == 4){
					binString = binString + "0000";
				}

				// Check if pixel is white or black
				for(var k=0; k<binString.length; k++){
					var color = 0;
					if(binString.charAt(k) == "1"){
						color = 255;
					}
					drawPixel(ctx, x, (page*8)+y, color);
					y--;
					if(y < 0){
						y = 7;
						x++;
						if(x >= settings["screenWidth"]){
							x = 0;
							page++;
						}
					 }

				}
			}
			// Save the canvas contents inside the img object. This way we can
			// reuse the img object when we want to scale / invert, etc.
			var img = new Image();
			img.src = canvas.toDataURL("image/png");
			images.first().img = img;
		}

<!------------------------------------------------------------------>
		 function toHex(s) {
			var a = s.toString(16);
			if ((a.length % 2) > 0) {
				a = "0" + a;
			}
			return a;
		}
 
<!------------------------------------------------------------------>
		// Convert hex to binary
		function hexToBinary(s) {

			var i, k, part, ret = "";
			// lookup table for easier conversion. "0" characters are
			// padded for "1" to "7"
			var lookupTable = {
				"0": "0000", "1": "0001", "2": "0010", "3": "0011", "4": "0100",
				"5": "0101", "6": "0110", "7": "0111", "8": "1000", "9": "1001",
				"a": "1010", "b": "1011", "c": "1100", "d": "1101", "e": "1110",
				"f": "1111", "A": "1010", "B": "1011", "C": "1100", "D": "1101",
				"E": "1110", "F": "1111"
			};
			for (i = 0; i < s.length; i += 1) {
				if (lookupTable.hasOwnProperty(s[i])) {
					ret += lookupTable[s[i]];
				} else {
					return { valid: false, s: s };
				}
			}
			return { valid: true, result: ret };
		}

		// Quick and effective way to draw single pixels onto the canvas
		// using a global 1x1px large canvas
		function drawPixel(ctx, x, y, color) {
			var single_pixel = ctx.createImageData(1,1);
			var d = single_pixel.data;

			d[0] = color;
			d[1] = color;
			d[2] = color;
			d[3] = 255;
			ctx.putImageData(single_pixel, x, y);
		}

		// get the type (in arduino code) of the output image
		// this is a bit of a hack, it's better to make this a property of the conversion function (should probably turn it into objects)
		function getType() {
			if (settings.conversionFunction == ConversionFunctions.horizontal565) {
				return "uint16_t";
			}else if(settings.conversionFunction == ConversionFunctions.horizontal888){
				return "unsigned long";
			}else{
				return "uint8_t";
			}
		}
		// --

		document.getElementById("scale").value = "2";
		document.getElementById("scale").onchange();
		document.getElementById("outputFormat").value = "arduino";
		document.getElementById("outputFormat").onchange();

	</script>

</html>
