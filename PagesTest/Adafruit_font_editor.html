<!--
	"Adafruit-GFX-Font-Customiser"
	Original utility by:
	https://tchapi.github.io/Adafruit-GFX-Font-Customiser/
	
	Modified version from Dony Oprekers
	https://github.com/oprekersmania/
-->

<html>
<head>
  <meta charset="utf-8">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.7.1/jquery.min.js" crossorigin="anonymous"></script>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/semantic-ui@2.4.2/dist/semantic.min.css">
  <script src="https://cdn.jsdelivr.net/npm/semantic-ui@2.4.2/dist/semantic.min.js"></script>
  <style>
    html, body {
      margin: 0 10px;
	  scroll-behavior: smooth;
    }
    textarea {
      font-family: "Courier", monotype;
      font-size: 0.9em !important;
    }

    .explanation ul {
      list-style-type: circle;
      margin: 0;
      padding-left: 14px;
    }

    .explanation h5 {
      margin-bottom: 4px;
      margin-top: 4px;
    }

    #glyphs div.inner {
      padding: 10px 0;
      position: relative;
    }
    #glyphs .centered.inner {
      padding: 10px;
      text-align: center;
    }

    #glyphs h2.inner {
      font-size: 2em;
      padding: 0.3em;
      text-align: center;
    }
    #glyphs div.table {
      user-select: none;
      position: relative;
      width: max-content;
      margin: auto;
    }
    #glyphs div.table div.row {
      height: 10px;
      position: relative;
    }
    #glyphs div.table div.row:first-child div.cell {
      height: 10px;
      border-top: 1px solid lightgrey;
    }
    #glyphs div.table div.cell {
      border-bottom: 1px solid lightgrey;
      border-right: 1px solid lightgrey;
      width: 10px;
      height: 10px;
      display: inline-block;
      cursor: pointer;
    }
    #glyphs div.table div.cell:first-child {
      border-left: 1px solid lightgrey;
    }
    #glyphs div.table div.cell.fill {
      background: black;
    }
    #glyphs div.table div.cell:hover {
      background: #999;
    }
    #glyphs div.table div.cell.fill.over {
      box-shadow: 0 0 9px #D00 inset;
    }
    #glyphs div.table div.cell.dead {
      background: #DDD;
    }
    #loader {
      position: fixed;
      top: 0;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0, 0, 0, 0.5);
      color: white;
      font-weight: bold;
      font-size: 2em;
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 10;
      display: flex;
      flex-direction: column;
    }
    .advance-wrapper {
      width: 300px;
      position: relative;
      border: 1px solid lightgray;
      height: 30px;
      margin-bottom: 20px;
    }
    .advance {
      opacity: 0.7;
      background: white;
      width: 10px;
      height: 24px;
      margin: 2px;
    }
    .baseline {
      position:absolute;
      left:0px;
      width:100%;
      height:1px;
      background-color:#090;
      opacity:0.6;
      pointer-events: none;
    }
    .limit {
      position: absolute;
      top: 0px;
      width: 2px;
      height: 100%;
      opacity: 0.4;
      pointer-events: none;
      background-color: #900;
    }
    #add {
      margin-top: 10px;
    }

    span.np {
      font-size: 0.5em;
      color: #CCC;
      font-style: italic;
    }

    .glyph-grid {
      display: flex;
      flex-wrap: wrap;
      align-items: stretch;
      justify-content: center;
    }
    .glyph-grid > div {
	      margin: 1rem;
      box-shadow: 3px 3px 8px rgba(0,0,0,0.15);
    }
    .ui.button{
      margin-top: 5px;
    }
	.ui.segment.teal {
    position: relative;
    background: #000;
	}
	.ui.form .field>label{
		color: #FFFFFF
	};
	
   </style>
</head>

<body>

<div id="title"> <!--	Area JUDUL	-->
  <a href="https://github.com/OprekersMania/Adafruit-GFX-Font-Customiser"><img style="position: absolute; top: 0; right: 0; border: 0;" src="https://camo.githubusercontent.com/365986a132ccd6a44c23a9169022c0b5c890c387/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f72696768745f7265645f6161303030302e706e67" alt="Fork me on GitHub" data-canonical-src="https://s3.amazonaws.com/github/ribbons/forkme_right_red_aa0000.png"></a>

	<div style="background-color: #37f21c54; margin-top: 25px; position: inherit;" class="ui red segment">
			<h2 style="font-size: 30px;">Adafruit GFX Pixel font customiser</h2>
	</div>
  
  <p style="padding: 15px;">
    <b><em>
		Created by <a href="https://github.com/tchapi">tchapi</a>, major improvements by <a href="https://github.com/cmarrin">cmarrin</a> and 
	    <a href="https://github.com/charno">charno</a> - Source code available on <a href="https://github.com/tchapi/Adafruit-GFX-Font-Customiser">Github</a>.
		</br>
		<a href="https://tchapi.github.io/Adafruit-GFX-Font-Customiser/" target="_blank"> Original Page</a> font customiser by tchapi.
		</em>
	</b>
	<br>
	<br>
		<em>
			<b>Additional layout and features, modified by ,  
				<a href="https://github.com/OprekersMania" target="_blank">Oprekers Mania.</a>   
			 <br>
			Online converter images to byte arrays or vice versa, for use in the Arduino LCD library, go to <a href="https://oprekersmania.github.io/image2cpp/" target="_blank">HERE</a></br>
			Online converter TTF fonts to AdafruitGFX fonts, go to <a href="https://rop.nl/truetype2gfx/" target="_blank">HERE</a>
			</b>
		</em>
	</p>
  <div class="ui divider"></div>
</div>

<div > <!--	Penjelasan Fungsi	-->
  <h2 class="ui header">How to use it</h2>
  <div class="ui grid">
    <div class="five wide column">
      <div class="ui explanation">
        <h5>Importing or creating a font:</h5>
        You can either:
        <ul>
          <li>Extract a font by copying &amp; pasting the existing font source (a <kbd>.h</kbd> file) in the textarea above</li>
          <li>Create a new font with a single character</li>
        </ul>
        <h5>Adding characters:</h5>
        <p>You can easily add new characters to the font afterwards. Interval characters will be added automatically <em>as disabled glyphs</em>.</p>
      </div>
    </div>
    <div class="eleven wide column">
      <div class="ui explanation">
        <h5>Editing glyphs:</h5>
        Glyphs can be edited individually. You can:
        <ul>
          <li>Enable or disable the glyph</li>
          <li>Edit each pixel of the glyph</li>
          <li>Edit all values present in the GFXglyph data structure (See <a href="https://learn.adafruit.com/creating-custom-symbol-font-for-adafruit-gfx-library/understanding-the-font-specification">Adafruit documentation</a> for more information)</li>
        </ul>
        <h5>When exporting, you can either :</h5>
        <ul>
          <li>Select a range of characters to include in the output. Characters outside of this range will <strong>not</strong> be included in the bitmap nor in the glyphs table.</li>
          <li>Disable individual characters. The disabled characters get all values set to <kbd>0</kbd>. There still are entries for the disabled characters in the glyphs table, but no data in the bitmap for them â€” this keeps the characters in their correct places in the ASCII table.</li>
        </ul>
      </div>
    </div>
  </div>
	<br>
	<br>
</div>
 
<div id="sumber">
    <div class="eight wide column" > <!--	Area File Sumber	-->
      <div class="ui teal segment">
        <div class="ui form">
          <div class="field">
            <label class="white">Extract Font Source</label>
            <textarea id="source" style="height: 155px;">
// SAMPLE TEXT FOR THIS PAGE		  
// Font AdafruitGfx = Nonstop12num.h
// Font Height = 12 pixels
// Font Set = ./0123456789
// Script editor mod by DONY OPREKERS

const uint8_t Nonstop12numBitmaps[] PROGMEM = {
  0xFF, 0x80, 0xFF, 0xFF, 0xFF, 0x7E, 0xFD, 0xFB, 0xF7, 0xFF, 0xFF, 0xF8, 
  0x00, 0xFF, 0xF7, 0x77, 0x77, 0x77, 0x70, 0xFF, 0xFF, 0xF8, 0x7F, 0xFF, 
  0xFF, 0xF0, 0xFF, 0xFF, 0xF8, 0x00, 0xFF, 0xFF, 0xF8, 0x7F, 0xFF, 0xFF, 
  0x87, 0xFF, 0xFF, 0xF8, 0x00, 0xEF, 0xDF, 0xBF, 0x7F, 0xFF, 0xFF, 0x87, 
  0x0E, 0x1C, 0x38, 0x00, 0xFF, 0xFF, 0xFF, 0x0F, 0xFF, 0xFF, 0x87, 0xFF, 
  0xFF, 0xF8, 0x00, 0xFF, 0xFF, 0xFF, 0x0F, 0xFF, 0xFF, 0xF7, 0xFF, 0xFF, 
  0xF8, 0x00, 0xFF, 0xFF, 0xF8, 0x70, 0xE1, 0xC3, 0x87, 0x0E, 0x1C, 0x38, 
  0x00, 0xFF, 0xFF, 0xFF, 0x7F, 0xFF, 0xFF, 0xF7, 0xFF, 0xFF, 0xF8, 0x00, 
  0xFF, 0xFF, 0xFF, 0x7F, 0xFF, 0xFF, 0x87, 0xFF, 0xFF, 0xF8, 0x00
};

const GFXglyph Nonstop12numGlyphs[] PROGMEM = {
//    Pos  Col  Row  Xadv  Xoff  Base    Ascii hex   Char    Hex Count
  {     0,   3,   3,   4,    0,    8 },   // 0x2E     '.'     '2'
  {     0,   0,   0,   0,    0,    0 },   // 0x2F     '/'     '0'
  {     2,   7,  11,   8,    0,    0 },   // 0x30     '0'     '11'
  {    13,   4,  11,   5,    0,    0 },   // 0x31     '1'     '6'
  {    19,   7,  11,   8,    0,    0 },   // 0x32     '2'     '11'
  {    30,   7,  11,   8,    0,    0 },   // 0x33     '3'     '11'
  {    41,   7,  11,   8,    0,    0 },   // 0x34     '4'     '11'
  {    52,   7,  11,   8,    0,    0 },   // 0x35     '5'     '11'
  {    63,   7,  11,   8,    0,    0 },   // 0x36     '6'     '11'
  {    74,   7,  11,   8,    0,    0 },   // 0x37     '7'     '11'
  {    85,   7,  11,   8,    0,    0 },   // 0x38     '8'     '11'
  {    96,   7,  11,   8,    0,    0 }    // 0x39     '9'     '11'
};

const GFXfont Nonstop12num PROGMEM = {
(uint8_t *) Nonstop12numBitmaps,
(GFXglyph *)Nonstop12numGlyphs,0x2E,0x39, 12 };

// Approx. 1684 bytes
			</textarea>
          </div>
			<label for="BukaFile" class="ui violet button" style="padding: 11px;"><i class="folder icon"></i> Open Font File</label>
			<input id="BukaFile" type="file" style="display:none;" >
            		<button class="ui button teal" id="extract"><i class="icon upload"></i> Extract</button>
            		<button class="ui button blue" id="createFont"><i class="icon file outline"></i> Create a new font</button>
			<button class="ui red button" id="hapus"><i class="eraser icon"></i>Clear Text</button>
			<input type="text" id="urlInput" placeholder="Paste URL link here" style="margin-top: 15px; margin-bottom: 15px;">
			<button class="ui purple button" id="urlFont" onclick="importFile()"><i class="icon file outline"></i>Import from URL</button>
			<button class="ui right floated button red" id="reset" ><i class="icon undo"></i> Reset</button>
        </div>
      </div>
    </div>
</div>
	<br>
	<div id="informasi" class="ui red segment" style="background-color: #b0fde8; display: none;">
	  <h2><font color="red">Editor will be viewed after new font created or extracted !!</font></h2>
	</div>
	<br>
	
<div id="hasil" class="ui teal segment" style="display: none; background-color: #b0fde8;">
  <h2 class="ui header" style="text-align: center;color: #0b00ad;">
  Please edit each character or add new characters if necessary. <br>
  To create font output, use "Output Generator" box area at bottom page.</h2>
  <div class="ui divider"></div>
  <h2 class="ui header">Glyphs set from font :  &nbsp <em class="fontname" style="display: none;">FontName unknown</em></h2>
  <p>
	<button class="ui small button violet" id="add" disabled="disabled"><i class="icon add"></i> Add a new character</button>
	<button class="ui small button red right floated" onclick='window.location="#resultWrapper"'><i class="angle double down icon"></i>Down</button>
</p>

  <div id="glyphs" class="ui glyph-grid" style="margin-bottom: 50px;">
  </div>
  
    <div class="eight wide column"style="margin-bottom: 50px;"> <!--	Area File Output	-->
      <div class="ui teal segment" id="resultWrapper" style="color:#FF0;">
        <div class="ui form">
          <div class="field">
            <label>Output Generator</label>
            <textarea id="result" style="height: 155px;" readonly></textarea>
          </div>
	<div>
		<label id="charRange" ><font color="red" >Selectable glyph range, active only on fullset ASCII font source</font></label>
		<div class="four fields" >
			<div class="field"><input class="check" name="ranges" type="radio" value="1" id="myCheckbox1" disabled/>&nbsp;&nbsp;&nbsp; Fullset ASCII</div>
			<div class="field"><input class="check" name="ranges" type="radio" value="2" id="myCheckbox2" disabled/>&nbsp;&nbsp;&nbsp; A-Z</div>                                                                                                      
			<div class="field"><input class="check" name="ranges" type="radio" value="3" id="myCheckbox3" disabled/>&nbsp;&nbsp;&nbsp; a-z</div>                                                                                                      
			<div class="field"><input class="check" name="ranges" type="radio" value="4" id="myCheckbox4" disabled/>&nbsp;&nbsp;&nbsp; 0-9</div>
		</div>
	</div>
	<div class="four fields">
		<div class="field" style="width:50%;">
			<label><font color="white">Change font name if needed, and process it</font></label>
			<input type="text" id="namafont" value="fontname" style="font-weight: bolder;">
		</div>
		<div class="field">
			<label>First glyph to export</label>
			<input type="text" id="firstglyph" value="0x00" />
		</div>
		<div class="field">
			<label>Last glyph to export</label>
			<input type="text" id="lastglyph" value="0x00" />
		</div>
	</div>
		<button class="ui button green" id="export" ><i class="icon download"></i> Proccess Font</button>
		<button class="ui teal button" id="copying"><i class="clipboard list icon"></i>Copy to clipboard</button>
		<button class="ui red button" id="savefile"><i class="save icon"></i>Save to file</button>
		<button class="ui blue button" id="editing"><i class="clone icon"></i>Re-Edit Result</button>
		<button class="ui green button right floated" onclick='window.location="#sumber"' ><i class="angle double up icon"></i>Up</button>
        </div>
      </div>
    </div>
	
</div>

  <div class="ui grid">

	<div class="ui small modal choose">
	  <div class="header">Add a new character</div>
	  <div class="content">
		<p>The character will be added to the set (<em>either at the end or at the beginning, depending on its code</em>), and if it is not contiguous with the previous set, <strong>the interval characters will be added too</strong>, but disabled, so that they do not take much space in the exported glyphs</p>
		<form class="ui form">
		<div class="field">
		  <div class="ui toggle checkbox use-charcode">
			<input type="checkbox" name="charcode" tabindex="0" class="hidden">
			<label>Use char code (hex)</label>
		  </div>
		</div>
		</form>
		<div class="ui right labeled input">
		  <input type="text" id="new-character" placeholder="Character to add" maxlength="1">
		  <a class="ui label">
			Char Code: <kbd class="charcode">N/A</kbd>
		  </a>
		</div>
		<div class="ui right labeled input">
		  <input type="text" id="new-character-code" value="0x" maxlength="4">
		  <a class="ui label">
			Character: <kbd class="character">N/A</kbd>
		  </a>
		</div>
	  </div>
	  <div class="actions">
		<div class="ui cancel red button">Cancel</div>
		<div class="ui approve green button">Add</div>
	  </div>
	</div>

	<div class="ui small modal newfont">
	  <div class="header">Create a new font</div>
	  <div class="content">
		<p>To create a new font, you need to provide some details.</p>
		<form class="ui form">
		<div class="field">
		  <label>Font name</label>
		  <input type="text" id="newfont-name" placeholder="Name of the new font">
		</div>
		<div class="field">
		  <label>Font height</label>
		  <p>Font height in pixels</p>
		  <input id="newfont-height"  type="number" value="5" min="5" placeholder="Height of the new font">
		</div>
		<div class="field">
		  <label>First character</label>
		  <p>The new font will be created with one character. You can add more characters later.</p>
		  <div class="ui toggle checkbox newfont-use-charcode">
			<input type="checkbox" name="newfontCharcode" tabindex="0" class="hidden">
			<label>Use char code (hex)</label>
		  </div>
		</div>

		</form>
		<div class="ui right labeled input">
		  <input type="text" id="newfont-new-character" placeholder="Character to add" maxlength="1">
		  <a class="ui label">
			Char Code: <kbd class="newfontCharcode">N/A</kbd>
		  </a>
		</div>
		<div class="ui right labeled input">
		  <input type="text" id="newfont-new-character-code" value="0x" maxlength="4">
		  <a class="ui label">
			Character: <kbd class="newfontCharacter">N/A</kbd>
		  </a>
		</div>
	  </div>
	  <div class="actions">
		<div class="ui cancel red button">Cancel</div>
		<div class="ui approve green button">Create</div>
	  </div>
	</div>

	<div class="ui small modal message">
	  <div class="header">?? Warning</div>
	  <div class="content">
		<p></p>
	  </div>
	  <div class="actions">
		<div class="ui approve blue button">Ok</div>
	  </div>
	</div>

	<div class="ui small modal confirmation">
	  <div class="header">?? Warning</div>
	  <div class="content">
		<p></p>
	  </div>
	  <div class="actions">
		<div class="ui cancel blue button">Cancel</div>
		<div class="ui approve red button">Reset</div>
	  </div>
	</div>

	<div id="loader">
		<div class="advance-wrapper"><div class="advance"></div></div>
		<span>Loading and extracting font ...</span>
	</div>
  
  </div>
  
</body>
<script>

document.getElementById('BukaFile')
.addEventListener('change', getFile)

function importFromURL(url, textAreaId) {
  fetch(url)
    .then(response => response.text())
    .then(content => {
      const textArea = document.getElementById(textAreaId);
      if (checkRegex(content)) {
        textArea.value = content;
		$('#extract').trigger('click');
      } else {
	alert('The content of this link does not contain the Adafruit GFXfont file format, wrong link, or does not exist!')
	$("#loader").hide()
	return
      }
    })
    .catch(error => {
	alert('Invalid URL or Wrong link!!\nMakesure link address is right')
	$("#loader").hide()
	return
    });
}

function checkRegex(content) {
  const regex = /const\s+unsigned\s+char|uint8_t\ (.*)Bitmaps\[\]/;
  return regex.test(content);
}

function importFile() {
  const urlInput = document.getElementById("urlInput");
  const fileURL = urlInput.value;
  const textAreaId = "source";
  // Memastikan URL tidak kosong dan berakhiran dengan ".h" sebelum memanggil fungsi importFromURL
  if (fileURL.trim() !== "" && fileURL.trim().toLowerCase().endsWith(".h")) {
	importFromURL(fileURL, textAreaId);
  } else {
	alert('Invalid URL !!\nNo correct http/https prefix and makesure include ".h" extention file')
	$("#loader").hide()
	return
  }
}

function getFile(event) {
	const input = event.target
  if ('files' in input && input.files.length > 0) {
	  placeFileContent(
      document.getElementById('source'),
      input.files[0])
  }    
}

function readFileContent(file) {
	const reader = new FileReader()
  return new Promise((resolve, reject) => {
    reader.onload = event => resolve(event.target.result)
    reader.onerror = error => reject(error)
    reader.readAsText(file)
  })
}

function placeFileContent(target, file) {
	readFileContent(file).then(content => {
  	target.value = content
  }).catch(error => console.log(error))
}

function saveTextAsFile() {
    var textToSave = document.getElementById("result").value;
    var textToSaveAsBlob = new Blob([textToSave], {type:"text/plain"});
    var textToSaveAsURL = window.URL.createObjectURL(textToSaveAsBlob);
 
    var downloadLink = document.createElement("a");
    downloadLink.href = textToSaveAsURL;
    downloadLink.download = name + '.h';
    downloadLink.innerHTML = "Download File";
    downloadLink.onclick = destroyClickedElement;
    downloadLink.style.display = "none";
    document.body.appendChild(downloadLink);
    downloadLink.click();
}
 
function destroyClickedElement(event){
    document.body.removeChild(event.target);
}
 
function makeUpDownButton (name, func, color, width) {
  const button = $('<div class="ui mini compact buttons" style="margin:1px"></div>')
  const style = 'ui compact button ' + func + '-handler ' + color
  button.append('<button id="' + func + '-remove" class="' + style + '">-</button>')
  button.append('<button id="' + func + '-value" class="ui compact disabled button ' + color + '" style="width:' + width + '">' + name + '</button>')
  button.append('<button id="' + func + '-add" class="' + style + '">+</button>')
  return button
}

function makeCheckButton (name, func, color, width, disabled) {
  const button = $('<span class="ui mini compact" style="margin:1px"></span>')
  button.append('<label class="ui '+color+' label" disabled style="width:' + width + '""><input type="checkbox" class="'+func+'-handler" id="'+func+'"' + (disabled ? ' checked="checked"' : '') + '> '+name+'</label>')
  return button
}

function makeGlyphItem (n, w, h, char, adv, ow, oh, disabled) {
  const charCode = char.charCodeAt(0)
  const table = $('<div class="table"></div>')
    .addClass('glyph')
    .attr('data-pixels', n)
    .attr('data-w', w)
    .attr('data-h', h)
    .attr('data-char', char)
    .attr('data-adv', adv)
    .attr('data-ow', ow)
    .attr('data-oh', oh)
    .attr('data-dis', disabled ? 1 : 0)
    .css('opacity', disabled ? 0.1 : 1)

  const grid = $(`<div style="width: ${window['glyph_table_width']}px"></div>`)
  const div = $('<div class="ui attached segment inner"></div>')

  div.append(table)

  if (char == ' ') {
    grid.append('<h2 class="ui top attached segment inner"><span class="np">space</span></h2>')
  } else  {
    // Display a specific text for non-printable characters
    grid.append('<h2 class="ui top attached segment inner">' + char.replace(/[\x00-\x1F\x7F-\x9F\xAD]/g, '<span class="np">non-printable</span>') + '</h2>')
  }

  grid.append('<div class="ui attached segment inner secondary centered">' + '0x' + charCode.toString(16).toUpperCase() + '</div>')
  grid.append(div)

  const buttonBar = $('<div class="ui bottom attached warning message inner centered"></div>')
  buttonBar.append(makeUpDownButton('Rows', 'row', 'purple', 50))
  buttonBar.append(makeUpDownButton('Cols', 'col', 'violet', 50))
  buttonBar.append(makeUpDownButton('Base', 'base', 'green', 50))
  buttonBar.append(makeUpDownButton('XOff', 'xoff', 'blue', 50))
  buttonBar.append(makeUpDownButton('XAdv', 'xadv', 'teal', 50))
  buttonBar.append(makeClipButtons('copy', 'brown', 'COPY', 20))
  buttonBar.append(makeClipButtons('paste', 'blue', 'PASTE', 20))
  buttonBar.append(makeClipButtons('undo', 'red', 'UNDO', 20))
  buttonBar.append(makeCheckButton('Disable', 'dis', 'yellow', 110, disabled))

  grid.append(buttonBar)

  return grid
}

function makeClipButtons(func, color, teks, width) {
    const button = $('<div class="ui mini compact buttons" style="margin:1px"></div>')
    const style = 'ui compact button ' + 'clip-handler ' + color
    button.append('<button id="clip-' + func + '" class="' + style + '">' + teks +'</button>')
    return button
}

function setGlyphTable (table) {
  const xadvance = parseInt(table.attr('data-adv'))
  const yadvance = parseInt(window['yAdvance'])

  const xoffset = parseInt(table.attr('data-ow'))
  const yoffset = parseInt(table.attr('data-oh'))

  const width = parseInt(table.attr('data-w'))
  const height = parseInt(table.attr('data-h'))

  const pixels = table.attr('data-pixels')

  const maxBaseline = window['maxBaseline']

  const left = xoffset
  const right = width + xoffset
  const top = maxBaseline + yoffset
  const bottom = top + height

  // Set the table
  table.empty()
  for (let i = 0; i < yadvance; i++) {
    const row = $('<div></div>').addClass('row')
    for (let j = Math.min(0, xoffset); j <= Math.max(xadvance, right); j++) {
      const cell = $('<div></div>').addClass('cell').attr('data-x', j).attr('data-y', i)
      // These classes are used to position the "limits" vertical lines
      if (i === 0 && j === 0) {
        cell.addClass('before_xoffset')
      }
      if (i === 0 && j === xadvance) {
        cell.addClass('before_xadvance')
      }
      // Now draw the actual pixels
      if (i < top || i >= bottom || j < left || j >= right) {
        cell.addClass('dead')
      } else if (pixels.charAt((i - top) * width + (j - left)) == '1') {
        cell.addClass('fill')
      }
      // If the pixel is after xadvance, or before xoffset
      if (j >= xadvance || j < Math.max(0, xoffset)) {
        cell.addClass('over')
      }
      row.append(cell)
    }
    table.append(row)
  }

  // Draw the xadvance/xoffset limits
  // (We need to get the actual cell position before hand)
  const left_xoffset = table.find('div.before_xoffset')[0].offsetLeft
  xoffset_limit = $('<div class="xoffset_limit limit"></div>').css('left', (left_xoffset - 1) + 'px') // -1 accounts for first border of table
  table.append(xoffset_limit)

  const left_xadvance = table.find('div.before_xadvance')[0].offsetLeft
  xadvance_limit = $('<div class="xadvance_limit limit"></div>').css('left', (left_xadvance - 1) + 'px')
  table.append(xadvance_limit)

  // Set the baseline
  baseline = $('<div class="baseline"></div>').css('top', ((maxBaseline + 1) * 10 - 1) + 'px')
  table.append(baseline)
}

function updatePixels (table, newWidth, newHeight, x, y, fill) {
  const dataPixels = table.attr('data-pixels')
  const width = parseInt(table.attr('data-w'))
  const height = parseInt(table.attr('data-h'))
  const xoff = parseInt(table.attr('data-ow'))
  const base = parseInt(table.attr('data-oh'))
  const xAdjust = xoff * -1
  const yAdjust = (window['maxBaseline'] + base) * -1

  if (newWidth < 0) {
    newWidth = width
  }

  if (newHeight < 0) {
    newHeight = height
  }

  if (x >= 0 && y >= 0) {
    x += xAdjust
    y += yAdjust
  }

  // Store the pixels into a 2D bool array
  const array = []
  let pixelIndex = 0
  for (let i = 0; i < height; ++i) {
    const rowArray = []
    for (let j = 0; j < width; ++j) {
      if(x == j && y == i) {
        rowArray.push(fill)
      } else {
        rowArray.push(dataPixels.charAt(pixelIndex))
      }
      ++pixelIndex
    }
    array.push(rowArray)
  }

  // Write out to a string newWidth x newHeight
  let newPixels = ''
  for (let i = 0; i < newHeight; ++i) {
    for (let j = 0; j < newWidth; ++j) {
      if (i >= height || j >= width) {
        newPixels += '0'
      } else {
        newPixels += array[i][j]
      }
    }
  }

  // Pad out to a multiple of 8
  const pad = newPixels.length % 8
  for (let i = 0; i < pad; ++i) {
    newPixels += '0'
  }

  table.attr('data-pixels', newPixels)
}

function advanceLoading (percent) {
  const element = document.querySelector('#loader .advance')
  element.style.width = Math.floor(294 * percent)
}

function extractFont () {
  let data = $('#source').val()
  $('#result').val('')
  $('#add').attr('disabled', false)

  // Extract name
  const re = /const\ uint8\_t\ (.*)Bitmaps\[\]/
  const found = data.match(re)

  if (found != null && found.length > 1) {
    window['name'] = found[1]
  } else {
    alert('No correct font file found, please paste the content of an Adafruit GFX font file first.')
    $("#loader").hide()
    return
  }

  $('#glyphs').empty()

  // extract GFXFont part
  const last_part_re = /const\ GFXfont([\s\S]*)/g
  const last_part = data.match(last_part_re)
  window['last_part'] = last_part[0]

  // Get first, last and yOffset
  let parts = last_part[0].split(',')
  const number_re = /0[xX][0-9a-fA-F]+|[0-9]+/gi
  window['first'] = parts[2].match(number_re)[0]
  window['last'] = parts[3].match(number_re)[0]
  window['yAdvance'] = parts[4].match(number_re)[0]

	if (window["first"] === '0x20' && window["last"] === '0x7E') {
		$('#myCheckbox1').prop({"disabled": false, "checked": false})
		$('#myCheckbox2').prop({"disabled": false, "checked": false})
		$('#myCheckbox3').prop({"disabled": false, "checked": false})
		$('#myCheckbox4').prop({"disabled": false, "checked": false})
		$('#charRange').html("Select glyph range of character or type manualy bellow on 'First' and 'Last glyph' if needed<br/>By default is use parameter from 'First' and 'Last glyph' on font source").css("color", "yellow")
	} else {
		$('#myCheckbox1').prop("disabled", true)
		$('#myCheckbox2').prop("disabled", true)
		$('#myCheckbox3').prop("disabled", true)
		$('#myCheckbox4').prop("disabled", true)
		$('#charRange').text("Selectable glyph range, active only on fullset ASCII font source").css("color", "red")
	}
	
  data = data.replace(last_part[0], '')
  data = data.replace(/\{/gi, '[').replace(/\}/gi, ']')
  data = data.replace('const GFXglyph ', '').replace('const uint8_t ', '').replace(/\[\]\ PROGMEM/gi, '')

  eval(data)

  /*
      // Tada ??
      console.log(window["name"])
      console.log(window["size"])
      console.log(window["first"])
      console.log(window["last"])
      console.log(window["last_part"])
      console.log(window[name + "Bitmaps"])
      console.log(window[name + "Glyphs"])
      */

  $('.fontname').text(window['name'].slice(0, window['name'].length)).show()
  $('#firstglyph').val(window["first"])
  $('#lastglyph').val(window["last"])

  //$('#add').attr('disabled', false)

  const glyphsArray = window[name + 'Glyphs']

  // Calculate the max yAdv to scale the table columns for the glyphs
  let maxW = 0
  for (ind in glyphsArray) {
    maxW = Math.max(maxW, glyphsArray[ind][1], glyphsArray[ind][3])
  }
  // Calculate the ideal glyph width. 160px is the minimum (for the buttons)
  window['glyph_table_width'] = Math.max(160, maxW * 11 + 30 /* some margin */)

  // Space from the baseline to the top of the character cell is determined by the character with the
  // largest negative yOffset.
  let maxBaseline = 0

  // Display tables
  for (ind in glyphsArray) {
    const charIndex = parseInt(ind)
    // for each glyph
    const char = String.fromCharCode(parseInt(window['first'], 16) + charIndex)
    const w = glyphsArray[ind][1]
    const h = glyphsArray[ind][2]
    const adv = glyphsArray[ind][3]
    const ow = glyphsArray[ind][4]
    const oh = glyphsArray[ind][5]
    let n = ''

    maxBaseline = Math.max(maxBaseline, -oh)

    // extract data: current offset
    currentOffset = glyphsArray[charIndex][0]

    // extract data: next offset
    if (charIndex + 1 < glyphsArray.length) {
      // To get the next offset, we need to find the next non-disabled
      // character offset (else, we will get 0 and it's not correct).
      let nextIndexIncrementor = 1
      do {
        nextOffset = glyphsArray[charIndex + nextIndexIncrementor][0]
        nextIndexIncrementor += 1
      } while (nextOffset === 0 && (charIndex + nextIndexIncrementor < glyphsArray.length))
      if (nextOffset === 0) { // We reached the end of the bitmaps
        nextOffset = window[name + 'Bitmaps'].length
      }
    } else {
      nextOffset = window[name + 'Bitmaps'].length
    }
    
    let disabled = (w == 0 || h == 0) && adv == 0

    if (!disabled) {
      for (let k = 0; k < (nextOffset - currentOffset); k++) {
        n += ('000000000' + window[name + 'Bitmaps'][currentOffset + k].toString(2)).substr(-8)
      }
    }

    grid = makeGlyphItem (n, w, h, char, adv, ow, oh, disabled)

    function glyphAppendClosure(el, adv, maxBaseline) {
      setTimeout(function () {
        advanceLoading(0.2 * adv)
        $('#glyphs').append(el)
        if (adv === 1) {
          // Run the setGlyphTable function now
          displayGlyphTable(maxBaseline)
        }
      }, 1)
    }

    glyphAppendClosure(grid, (charIndex + 1) / glyphsArray.length, maxBaseline)
  }
  
  $('#namafont').val(name)
  $('#informasi').hide()
  $('#hasil').show()
	 $('html, body').animate({
        scrollTop: $("#hasil").offset().top
    }, 0);
  // $('#export').prop( "disabled", false ) 
  // $('#reset').prop("disabled", false) 
  // $('#createFont').prop( "disabled", true )
  // $('#extract').prop( "disabled", true )
}

function displayGlyphTable (maxBaseline) {
  window['maxBaseline'] = maxBaseline

  const l = $('#glyphs').children().length
  $('#glyphs').children().each(function (i) {

    function setGlyphTableClosure(el, adv) {
      setTimeout(function () {
        advanceLoading(0.2 + 0.8 * adv)
        setGlyphTable(el.children().find('.glyph'))
        if (adv === 1) {
          $('#loader').hide()
        }
      }, 1)
    }

    setGlyphTableClosure($(this), (i + 1) / l)
  })
}

function calculateFileSize(headerContent) {
  const blob = new Blob([headerContent], { type: 'text/plain' })
  const fileSizeInBytes = blob.size
  const fileSizeInKB = fileSizeInBytes / 1024
  return fileSizeInKB.toFixed(2)
}

<!-------------------------------------------------------->
<!-------------------------------------------------------->
<!------                 MAIN SCRIPT                ------>
<!-------------------------------------------------------->
<!-------------------------------------------------------->

$(document).ready(function () {
 
  $('#informasi').show()
  $('#hasil').hide()
  var clip_data = {}
  var undo_data = {}
  let Cc = false;

  $('#new-character-code').parent().hide()
  // $('#add').attr('disabled', 'disabled')
  // $('#export').attr('disabled', 'disabled')
  // $('#reset').prop("disabled", 'disabled')
  $('.ui.checkbox.use-charcode').checkbox()

  $(document).on('change', '.ui.checkbox.use-charcode input', function (e) {
    $('#new-character').parent().toggle()
    $('#new-character-code').parent().toggle()
    
    if ($('input[name=charcode]').is(':checked')) {
      if ($('#new-character-code').val() == '') {
        $('.character').text('N/A')
      } else {
        $('.character').text(String.fromCharCode(parseInt($('#new-character-code').val(), 16)))
      }
    } else {
      if ($('#new-character').val() == '') {
        $('.charcode').text('N/A')
      } else {
        $('.charcode').text('0x' + $('#new-character').val().charCodeAt(0).toString(16).toUpperCase())
      }
    }
  })
  
  $('#newfont-new-character-code').parent().hide()
  $('.ui.checkbox.newfont-use-charcode').checkbox()
  $(document).on('change', '.ui.checkbox.newfont-use-charcode input', function (e) {
    $('#newfont-new-character').parent().toggle()
    $('#newfont-new-character-code').parent().toggle()
    
    if ($('input[name=newfontCharcode]').is(':checked')) {
      if ($('#newfont-new-character-code').val() == '') {
        $('.newfontCharacter').text('N/A')
      } else {
        $('.newfontCharacter').text(String.fromCharCode(parseInt($('#newfont-new-character-code').val(), 16)))
      }
    } else {
      if ($('#newfont-new-character').val() == '') {
        $('.newfontCharcode').text('N/A')
      } else {
        $('.newfontCharcode').text('0x' + $('#newfont-new-character').val().charCodeAt(0).toString(16).toUpperCase())
      }
    }
  })

  $('#loader').hide()
  window['name'] = null
  window['last_part'] = null

  $('#extract').click(function () {
    advanceLoading(0)
    $('#loader').fadeIn(function() {
      extractFont()
    })
  })

  $('#reset').click(function () {
  
    $('.ui.modal.confirmation p').text('The reset will close the font and discard any changes you made.')
    $('.ui.modal.confirmation').modal({
      closable: false,
      onApprove: function() {
        $('#glyphs').empty()
        $('#source').val('')
        $('#result').val('')
        $('#add').prop("disabled", "disabled")
		$('#urlInput').val('')
      
	$('#myCheckbox1').prop("disabled", true)
	$('#myCheckbox2').prop("disabled", true)
	$('#myCheckbox3').prop("disabled", true)
	$('#myCheckbox4').prop("disabled", true)
	$('#charRange').text("Selectable glyph range, active only on fullset ASCII font source").css("color", "red")
	      
		$('#hasil').hide()
		$('#informasi').show()
        // $('#createFont').prop("disabled", false) 
        // $('#extract').prop("disabled", false)
        // $('#export').prop("disabled", "disabled")
        // $('#reset').prop("disabled", "disabled") 
        $('.fontname').text('Fontname unknown').hide()
      }
    }).modal('show')
  })
  
  $("input[name='ranges'].check").click(function() {
    if($(this).is(':checked')) {
        if ($(this).val() == 1) {
            $("#firstglyph").val("0x20");
            $("#lastglyph").val("0x7E");
        }
        if ($(this).val() == 2) {
            $("#firstglyph").val("0x41");
            $("#lastglyph").val("0x5A");
        }
        if ($(this).val() == 3) {
            $("#firstglyph").val("0x61");
            $("#lastglyph").val("0x7A");
        }
        if ($(this).val() == 4) {
            $("#firstglyph").val("0x30");
            $("#lastglyph").val("0x39");
        }
    }
	});

<!--------------------------------------------------->
<!------        FUNGSI Edit ulang hasil        ------>
<!--------------------------------------------------->
  $('#editing').click(function () {
	let input = $('#result').val()
	if (input.length === 0) {
		  document.getElementById("ErrorMsg").style.display = "block";
		  setTimeout(function(){ document.getElementById("ErrorMsg").style.display = "none"; }, 1000);
		return;
	}
	$('#source').val('')
    $('#glyphs').empty()
    $('#source').val(input)
	$('#urlInput').val('')
    extractFont()
    $('#result').val('')
    // $('#extract').prop("disabled", false)
  })
  
<!----------------------------------------------->
<!------       FUNGSI hapus teks area      ------>
<!----------------------------------------------->
  $('#hapus').click(function () {
        $('#source').val('')
        // $('#extract').prop("disabled", false)
  })
  
<!----------------------------------------------->
<!------     FUNGSI simpan font ke file    ------>
<!----------------------------------------------->
  $('#savefile').click(function () {
     saveTextAsFile()
  })
  
<!---------------------------------------------------->
<!------        FUNGSI copy to clipboard        ------>
<!---------------------------------------------------->
  $('#copying').click(function () {
  
	  var copyText = document.getElementById("result");
	  copyText.select();
	  copyText.setSelectionRange(0, 9999999); /*Change higher if all content not copied*/
	  document.execCommand("copy");
  })

  $(document).on('click', '.clip-handler', function (e) {
    const targetID = $(e.target).attr('id')
    const table = $(e.target).parent().parent().parent().find('.table.glyph')
    if (targetID === 'clip-copy') {
      clip_data.xadvance  = parseInt(table.attr('data-adv'))
      clip_data.xoffset   = parseInt(table.attr('data-ow'))
      clip_data.yoffset   = parseInt(table.attr('data-oh'))        
      clip_data.width     = parseInt(table.attr('data-w'))
      clip_data.height    = parseInt(table.attr('data-h'))        
      clip_data.pixels    = table.attr('data-pixels')
    } else if (targetID === 'clip-paste') {
      undo_data.xadvance   = parseInt(table.attr('data-adv'))
      undo_data.xoffset   = parseInt(table.attr('data-ow'))
      undo_data.yoffset   = parseInt(table.attr('data-oh'))        
      undo_data.width     = parseInt(table.attr('data-w'))
      undo_data.height    = parseInt(table.attr('data-h'))        
      undo_data.pixels    = table.attr('data-pixels')
	  Cc=true;
      table.attr('data-adv',      clip_data.xadvance)
      table.attr('data-ow',       clip_data.xoffset)
      table.attr('data-oh',       clip_data.yoffset)
      table.attr('data-w',        clip_data.width)
      table.attr('data-h',        clip_data.height)
      table.attr('data-pixels',   clip_data.pixels)
    } else if (targetID === 'clip-undo') {
		if (Cc){
      table.attr('data-adv',      undo_data.xadvance)
      table.attr('data-ow',       undo_data.xoffset)
      table.attr('data-oh',       undo_data.yoffset)
      table.attr('data-w',        undo_data.width)
      table.attr('data-h',        undo_data.height)
      table.attr('data-pixels',   undo_data.pixels)
	  Cc=false;
	  }
    }
    setGlyphTable(table)
    return false
  })


  const fillPixel = (target, fill) => {
    fill === '1' ? target.addClass('fill') : target.removeClass('fill')
    const table = target.parent().parent().parent().find('.table.glyph')
    updatePixels(table, -1, -1, parseInt(target.attr('data-x')), parseInt(target.attr('data-y')), fill)
  }

  let isFilling = false;
  let fillingMode = '1';
  $(document).on('mousedown', '.cell:not(.dead)', function (e) {
    isFilling = true;
    fillingMode = $(e.target).hasClass('fill') ? '0' : '1'
    fillPixel($(e.target), fillingMode)
  })
  $(document).on('mouseup', '.cell:not(.dead)', function (e) {
    isFilling = false;
  })
  $(document).on('mouseenter', '.cell:not(.dead)', function (e) {
    if (isFilling) {
      fillPixel($(e.target), fillingMode)
    }
  })

  $(document).on('click', '.row-handler', function (e) {
    const targetID = $(e.target).attr('id')
    const table = $(e.target).parent().parent().parent().find('.table.glyph')
    let height = parseInt(table.attr('data-h'))

    if (targetID === 'row-add') {
      height++
    } else if (targetID === 'row-remove') {
      height--
    }

    updatePixels(table, -1, height, -1, -1, false)
    table.attr('data-h', height)
    setGlyphTable(table)
    return false
  })

  $(document).on('click', '.col-handler', function (e) {
    const targetID = $(e.target).attr('id')
    const table = $(e.target).parent().parent().parent().find('.table.glyph')
    let width = parseInt(table.attr('data-w'))

    if (targetID === 'col-add') {
      width++
    } else if (targetID === 'col-remove') {
      width--
    }

    updatePixels(table, width, -1, -1, -1, false)
    table.attr('data-w', width)
    setGlyphTable(table)
    return false
  })

  $(document).on('click', '.base-handler', function (e) {
    const targetID = $(e.target).attr('id')
    const table = $(e.target).parent().parent().parent().find('.table.glyph')
    if (targetID === 'base-add') {
      table.attr('data-oh', parseInt(table.attr('data-oh')) + 1)
    } else if (targetID === 'base-remove') {
      table.attr('data-oh', parseInt(table.attr('data-oh')) - 1)
    }

    setGlyphTable(table)
    return false
  })

  $(document).on('click', '.xadv-handler', function (e) {
    const targetID = $(e.target).attr('id')
    const table = $(e.target).parent().parent().parent().find('.table.glyph')
    if (targetID === 'xadv-add') {
      table.attr('data-adv', parseInt(table.attr('data-adv')) + 1)
    } else if (targetID === 'xadv-remove') {
      table.attr('data-adv', parseInt(table.attr('data-adv')) - 1)
    }

    setGlyphTable(table)
    return false
  })

  $(document).on('click', '.xoff-handler', function (e) {
    const targetID = $(e.target).attr('id')
    const table = $(e.target).parent().parent().parent().find('.table.glyph')
    if (targetID === 'xoff-add') {
      table.attr('data-ow', parseInt(table.attr('data-ow')) + 1)
    } else if (targetID === 'xoff-remove') {
      table.attr('data-ow', parseInt(table.attr('data-ow')) - 1)
    }

    setGlyphTable(table)
    return false
  })

  $(document).on('change', '.dis-handler', function (e) {
    const table = $(e.target).parent().parent().parent().parent().find('.table.glyph')
    table.attr('data-dis', 1 - parseInt(table.attr('data-dis')))
    table.fadeTo('fast', 1 - 0.9 * table.attr('data-dis'))
    return false
  })

  $(document).on('keyup', '#new-character', function (e) {
    if ($('#new-character').val() == '') {
      $('.charcode').text('N/A')
    } else {
      $('.charcode').text('0x' + $('#new-character').val().charCodeAt(0).toString(16).toUpperCase())
    }
  })

  $(document).on('keyup', '#new-character-code', function (e) {
    if ($('#new-character-code').val() == '') {
      $('.character').text('N/A')
    } else {
      $('.character').text(String.fromCharCode(parseInt($('#new-character-code').val(), 16)))
    }
  })
  
  $(document).on('keyup', '#newfont-new-character', function (e) {
    if ($('#newfont-new-character').val() == '') {
      $('.newfontCharcode').text('N/A')
    } else {
      $('.newfontCharcode').text('0x' + $('#newfont-new-character').val().charCodeAt(0).toString(16).toUpperCase())
    }
  })

  $(document).on('keyup', '#newfont-new-character-code', function (e) {
    if ($('#newfont-new-character-code').val() == '') {
      $('.newfontCharacter').text('N/A')
    } else {
      $('.newfontCharacter').text(String.fromCharCode(parseInt($('#newfont-new-character-code').val(), 16)))
    }
  })
  
  $('#createFont').click(function () {
    $('input[name=newfontCharcode]').prop('checked', false)
    $('#newfont-new-character').parent().show()
    $('#newfont-new-character-code').parent().hide()
    if ($('#newfont-new-character').val() == '') {
      $('.charcode').text('N/A')
    } else {
      $('.charcode').text('0x' + $('#newfont-new-character').val().charCodeAt(0).toString(16).toUpperCase())
    }
    if ($('#newfont-new-character-code').val() == '') {
      $('.character').text('N/A')
    } else {
      $('.character').text(String.fromCharCode($('#newfont-new-character-code').val()))
    }
    
    $('.ui.modal.newfont').modal({
      closable: false,
      
      onApprove: function() {
        let name = $('#newfont-name').val()
        if (name.length < 1) {
          $('.ui.modal.message p').text('The font must have a name, I\'m not creating a new font with it.')
          $('.ui.modal.message').modal('show')
          return
        }
        
        
        let newfontHeight = parseInt($('#newfont-height').val())
        if (newfontHeight < 1) {
          $('.ui.modal.message p').text('The font height must be greater than 0, I\'m not creating a new font with it.')
          $('.ui.modal.message').modal('show')
          return
        }
        
        
        // Get new character data
        let newChar
        let newCharCode
        if ($('input[name=newfontCharcode]').is(':checked')) {
          newCharCode = parseInt($('#newfont-new-character-code').val(), 16)
          newChar = String.fromCharCode(newCharCode)
        } else {
          newChar = $('#newfont-new-character').val()
          newCharCode = $('#newfont-new-character').val().charCodeAt(0)
        }

        // Check character validity
        if (newChar == '') {
          $('.ui.modal.message p').text('This character is either blank or incorrect, I\'m not creating a new font with it.')
          $('.ui.modal.message').modal('show')
          return
        }

        if (newCharCode < 1) {
          $('.ui.modal.message p').text('This is a special control character, I\'m not creating a new font with it.')
          $('.ui.modal.message').modal('show')
          return
        }

        if (newCharCode > 65535) {
          $('.ui.modal.message p').text('This character is out of range, I\'m not creating a new font with it.')
          $('.ui.modal.message').modal('show')
          return
        }
        
        // Set the font parameters
        window['first'] = newCharCode
        window['last'] = newCharCode
        window['yAdvance'] = newfontHeight
        window['name'] = name + '_'
        window[name + '_Bitmaps'] = [] // This is otherwise created by the eval() in extract font
        window['maxBaseline'] = newfontHeight
        window['last_part'] = 'const GFXfont ' + name + ' PROGMEM = {(uint8_t *) ' + name + '_Bitmaps, (GFXglyph *)' + name + '_Glyphs, 0x00, 0x00, ' + newfontHeight + '};'
        
        // Show the data
        $('.fontname').text('(' + name + ')').show()
        $('#firstglyph').val('0x' + window["first"].toString(16))
        $('#lastglyph').val('0x' + window["last"].toString(16))
        $('#glyphs').empty()

        
        // Change button states
        $('#add').attr('disabled', false)
		$('#informasi').hide()
		$('#hasil').show()
		 $('html, body').animate({
			scrollTop: $("#hasil").offset().top
		}, 0);
		$('#result').val('')
        // $('#export').prop( "disabled", false )
        // $('#createFont').prop( "disabled", true )
        // $('#extract').prop( "disabled", true )
        // $('#reset').prop("disabled", false)
        
        // Add the new character
        const grid = makeGlyphItem (' ' , 1, 1, newChar, 4, 0, -newfontHeight, false)
        $('#glyphs').append(grid)
		$('#namafont').val(name);
        
        setGlyphTable(grid.find('.glyph'))
      }
    })
    .modal('show')
  })

  $('#add').click(function () {
    $('input[name=charcode]').prop('checked', false)
    $('#new-character').parent().show()
    $('#new-character-code').parent().hide()
    if ($('#new-character').val() == '') {
      $('.charcode').text('N/A')
    } else {
      $('.charcode').text('0x' + $('#new-character').val().charCodeAt(0).toString(16).toUpperCase())
    }
    if ($('#new-character-code').val() == '') {
      $('.character').text('N/A')
    } else {
      $('.character').text(String.fromCharCode($('#new-character-code').val()))
    }
    
    // Choose a character
    $('.ui.modal.choose').modal({
      closable: false,
      onApprove: function() {
        const firstglyph = parseInt($('#firstglyph').val(), 16)
        const lastglyph = parseInt($('#lastglyph').val(), 16)

        let newChar
        let newCharCode
        if ($('input[name=charcode]').is(':checked')) {
          newCharCode = parseInt($('#new-character-code').val(), 16)
          newChar = String.fromCharCode(newCharCode)
        } else {
          newChar = $('#new-character').val()
          newCharCode = $('#new-character').val().charCodeAt(0)
        }

        if (newChar == '') {
          $('.ui.modal.message p').text('This character is either blank or incorrect, I\'m not adding it.')
          $('.ui.modal.message').modal('show')
          return
        }

        if (newCharCode < 1) {
          $('.ui.modal.message p').text('This is a special control character, I\'m not adding it.')
          $('.ui.modal.message').modal('show')
          return
        }

        if (newCharCode > 65535) {
          $('.ui.modal.message p').text('This character is out of range, I\'m not adding it.')
          $('.ui.modal.message').modal('show')
          return
        }

        // Check that the character is not already existing
        if (newCharCode > lastglyph || newCharCode < firstglyph) {
          let start, end;
          if (newCharCode > lastglyph) {
            start = lastglyph + 1
            end = newCharCode
            window['last'] = '0x' + newCharCode.toString(16).toUpperCase()
            $('#lastglyph').val(window['last'])
          } else {
            start = newCharCode
            end = firstglyph - 1
            window['first'] = '0x' + newCharCode.toString(16).toUpperCase()
            $('#firstglyph').val(window['first'])
          }
          
          if (newCharCode < firstglyph) {
            for (j = end; j >= start; j--) {
              const char = String.fromCharCode(parseInt(j))
              const grid = makeGlyphItem (' ', 1, 1, char, 4, 0, -window['maxBaseline'], !(j === newCharCode))
              $('#glyphs').prepend(grid)
              setGlyphTable(grid.find('.glyph'))
            }
          } else {
            for (j = start; j <= end; j++) {
              const char = String.fromCharCode(parseInt(j))
              const grid = makeGlyphItem (' ', 1, 1, char, 4, 0, -window['maxBaseline'], !(j === newCharCode))
              $('#glyphs').append(grid)
              setGlyphTable(grid.find('.glyph'))
            }
          }
          
        } else {
          $('.ui.modal.message p').text('This character is already present in the actual set, I\'m not adding it.')
          $('.ui.modal.message').modal('show')
        }
      }
    })
    .modal('show');

  })

	<!----------------------------------------------->
	<!------            Export Font            ------>
	<!----------------------------------------------->
  $('#export').click(function () {
    name = $('#namafont').val()
    const glyphs = []
    const bitsArray = []
    let offset = 0
    let lineBreak = 37
    let Charset = ''
    let Usable_Char = ''
    let Usable_CharBreak = 37
    const firstglyph = parseInt($('#firstglyph').val(), 16)
    const lastglyph = parseInt($('#lastglyph').val(), 16)
    let fixlastglyph = ''

    $('.table.glyph').each(function () {
      const t = $(this)
      // Ignore glyphs outside of requested range
      if (t.attr('data-char').charCodeAt(0) < firstglyph || t.attr('data-char').charCodeAt(0) > lastglyph) {
        return
      }

      var dataPixels = $(this).attr('data-pixels')
      if (t.attr('data-dis') == 1) {
        dataPixels = ''
      }
      let bits = ''

      for (let i = 0; i < dataPixels.length; i++) {
        bits += dataPixels.charAt(i)
        // Each 8 bits, we form the HEX value
        if (bits.length == 8) {
          bitsArray.push('0x' + ('00' + parseInt((bits + '00000000').slice(0, 8), 2).toString(16).toUpperCase()).slice(-2))
          bits = ''
        }
      }

      // Remaining bits with padding then, if necessary
      if (bits != '') {
        bitsArray.push('0x' + ('00' + parseInt((bits + '00000000').slice(0, 8), 2).toString(16).toUpperCase()).slice(-2))
      }

      // Set data width/height to 0 for disabled glyphs
      const w = parseInt(t.attr('data-w')) * (1 - parseInt(t.attr('data-dis')))
      const h = parseInt(t.attr('data-h')) * (1 - parseInt(t.attr('data-dis')))

      let char = t.attr('data-char')
      const charCode = char.charCodeAt(0).toString(16).toUpperCase()
      const charDisplay = char.replace(/[\x00-\x1F\x7F-\x9F\xAD]/g, 'non-printable')
      if (charDisplay == ' ') { 
		Charset = 'space' 
		Usable_Char = 'space' 
		}
      Charset += charDisplay
	  if (h > 0) { Usable_Char += charDisplay }
      if (Usable_Char.length > Usable_CharBreak){
	  Usable_Char += '\n//                    '
	  Usable_CharBreak += Usable_Char.length 
      }
      if (Charset.length > lineBreak){
	  Charset += '\n//                    '
	  lineBreak += Charset.length 
      }
	  fixlastglyph = charCode

	  let ByteCount=(bitsArray.length - offset)
	  if ((bitsArray.length - offset) < 10) ByteCount += ' '
	  
      const comment = '// 0x' + charCode + '       \'' + ByteCount + '\'' + '     \'' + charDisplay + '\''
      
      if (t.attr('data-dis') == 0) {
        glyphs.push(
          '  { ' +
          ('     ' + offset).slice(-5) + ', ' +
          ('   ' + w).slice(-3) + ', ' +
          ('   ' + h).slice(-3) + ', ' +
          ('   ' + parseInt(t.attr('data-adv'))).slice(-3) + ', ' +
          ('    ' + parseInt(t.attr('data-ow'))).slice(-4) + ', ' +
          ('    ' + parseInt(t.attr('data-oh'))).slice(-4) + ' },   ' +
          comment)
      } else {
        glyphs.push(
          '  { ' +
          '    0, ' +
          '  0, ' +
          '  0, ' +
          '  0, ' +
          '   0, ' +
          '   0 },   ' +
          comment)
      }
      
      offset = bitsArray.length
    })

    // Bitmaps
    let bitmapsOutput = 'const uint8_t ' + name + 'Bitmaps[] PROGMEM = {\n'
    // We want to join per 12 words
    const limit = Math.floor(bitsArray.length / 12)
    for (let nb = 0; nb < limit; nb++) {
      const isLastLine = (limit * 12 === bitsArray.length) && (nb === limit - 1)

      bitmapsOutput += '  ' + bitsArray[nb * 12] + ', ' +
                              bitsArray[nb * 12 + 1] + ', ' +
                              bitsArray[nb * 12 + 2] + ', ' +
                              bitsArray[nb * 12 + 3] + ', ' +
                              bitsArray[nb * 12 + 4] + ', ' +
                              bitsArray[nb * 12 + 5] + ', ' +
                              bitsArray[nb * 12 + 6] + ', ' +
                              bitsArray[nb * 12 + 7] + ', ' +
                              bitsArray[nb * 12 + 8] + ', ' +
                              bitsArray[nb * 12 + 9] + ', ' +
                              bitsArray[nb * 12 + 10] + ', ' +
                              bitsArray[nb * 12 + 11] + (isLastLine ? '' : ',') + ' \n'
    }

    if (limit * 12 !== bitsArray.length) {
      bitmapsOutput += '  ' + bitsArray.slice(-(bitsArray.length - limit * 12)).join(', ') + '\n'
    }
    bitmapsOutput += '};\n\n'

    // Glyphs
    let infoGlyphs = '  //  Pos  Col  Row  Xadv  Xoff  Base    Ascii hex   Byte Count  Char\n'
    let Info =	
		'// Font Name        : ' + name + '.h\n' + 
		'// Font Height      : ' + parseInt(window['yAdvance']) + ' pixels\n' + 
		'// Character Set    : ' + Charset + '\n' +
		'// Character Usable : ' + Usable_Char + '\n' +
		'// Script modified by DONY OPREKERS\n\n' 
    // The last glyph has a ',' too much at the end, we need to remove it (it's easier than to avoid putting it in the first place)
    glyphs[glyphs.length - 1] = glyphs[glyphs.length - 1].replace('},', '} ')
    let glyphsOutput = 'const GFXglyph ' + name + 'Glyphs[] PROGMEM = {\n' + infoGlyphs
    glyphsOutput += glyphs.join('\n') + '\n};\n\n'

    // Create a new last_part with the updated first & last glyph values in it
    let parts = window['last_part'].split(',')    
    parts[0] = 'const GFXfont ' + name + ' PROGMEM = {\n' +
	       '  (uint8_t *) ' + name + 'Bitmaps'
    parts[1] = '\n  (GFXglyph *)' + name + 'Glyphs'
    parts[2] = '0x' + firstglyph.toString(16).toUpperCase()
    parts[3] = '0x' + fixlastglyph
    let last_part = parts.join(", ",parts)
	
	// Cleaning any comment at bottom page if exist
    let re = /const\ GFXfont([\s\S]*?});/;
    let last_match = last_part.match(re);
    last_part = last_match ? last_match[0] : "";

    data = Info + bitmapsOutput + glyphsOutput + last_part
    // Create a file size info text at bottom page
    const fileSizeInKB = calculateFileSize(data);
    data = data + '\n\n// File size approx : ' + fileSizeInKB + 'kb'
    $('#result').val(data)
  })
})

</script>
</html>
